/*2025*/
function leafletMapInitialize(t, n, e) { var i, o, s, r; !function (t) { var e = !1; if (void 0 !== document.styleSheets) { var i = document.styleSheets; document.location.origin || (document.location.origin = document.location.protocol + "//" + document.location.hostname + (document.location.port ? ":" + document.location.port : "")); var n = RegExp("^" + document.location.origin); t: for (var o = 0; o < i.length; o++){ var s = i[o]; if (null === s.href || null !== n.exec(s.href)) for (var r = void 0 !== s.cssRules ? s.cssRules : s.rules, a = 0; a < r.length; a++)if (r[a].selectorText == t) { e = !0; break t } } } return e }(".leaflet-pane") || (e = e || null, i = document.getElementById(t), o = t + "__map", s = { red: "rgb(253,117,103)", orange: "rgb(255,153,0)", yellow: "rgb(253,245,105)", green: "rgb(0,230,77)", blue: "rgb(105,145,253)", purple: "rgb(142,103,253)", pink: "rgb(230,97,172)" }, t = document.querySelector("html"), console.log(t), t.classList ? t.classList.add("js-map") : t.className += " js-map", i.innerHTML = "", (t = document.createElement("div")).id = o, i.appendChild(t), r = L.map(o, { center: [n.lat, n.lng], minZoom: 2, zoom: n.zoom, fullscreenControl: !0, fullscreenControlOptions: { position: "topleft" } }), L.tileLayer("https://api.mapbox.com/styles/v1/{id}/tiles/{z}/{x}/{y}?access_token={accessToken}", { attribution: 'Map data &copy; <a href="https://www.openstreetmap.org/">OpenStreetMap</a> contributors, <a href="https://creativecommons.org/licenses/by-sa/2.0/">CC-BY-SA</a>, Imagery Â© <a href="https://www.mapbox.com/">Mapbox</a>', maxZoom: 18, id: "mapbox/streets-v11", tileSize: 512, zoomOffset: -1, accessToken: n.token }).addTo(r), e && e.forEach(function (t, e) { "true" == t.lat && (t.lat = n.lat), "true" == t.lng && (t.lng = n.lng); var i = "" == t.color ? "red" : t.color, i = new L.Marker.SVGMarker([t.lat, t.lng], { iconOptions: { fillOpacity: 1, iconSize: [21, 32], circleFillColor: "rgb(0,0,0)", circleWeight: 0, circleRatio: .15, weight: 1.5, color: "rgb(0,0,0)", fillColor: s[i] } }); "string" == typeof t.popup && i.bindPopup(t.popup), i.addTo(r) }), "function" == typeof Event ? window.dispatchEvent(new Event("resize")) : ((e = window.document.createEvent("UIEvents")).initUIEvent("resize", !0, !1, window, 0), window.dispatchEvent(e))) } !function (t, e) { "object" == typeof exports && "undefined" != typeof module ? e(exports) : "function" == typeof define && define.amd ? define(["exports"], e) : e((t = "undefined" != typeof globalThis ? globalThis : t || self).leaflet = {}) }(this, function (t) { "use strict"; function l(t) { for (var e, i, n = 1, o = arguments.length; n < o; n++)for (e in i = arguments[n]) t[e] = i[e]; return t } var s = Object.create || function (t) { return e.prototype = t, new e }; function e() { } function a(t, e) { var i = Array.prototype.slice; if (t.bind) return t.bind.apply(t, i.call(arguments, 1)); var n = i.call(arguments, 2); return function () { return t.apply(e, n.length ? n.concat(i.call(arguments)) : arguments) } } var i = 0; function h(t) { return "_leaflet_id" in t || (t._leaflet_id = ++i), t._leaflet_id } function n(t, e, i) { var n, o, s = function () { n = !1, o && (r.apply(i, o), o = !1) }, r = function () { n ? o = arguments : (t.apply(i, arguments), setTimeout(s, e), n = !0) }; return r } function o(t, e, i) { var n = e[1], o = e[0], e = n - o; return t === n && i ? t : ((t - o) % e + e) % e + o } function c() { return !1 } function r(t, e) { if (!1 === e) return t; e = Math.pow(10, void 0 === e ? 6 : e); return Math.round(t * e) / e } function u(t) { return t.trim ? t.trim() : t.replace(/^\s+|\s+$/g, "") } function d(t) { return u(t).split(/\s+/) } function _(t, e) { for (var i in Object.prototype.hasOwnProperty.call(t, "options") || (t.options = t.options ? s(t.options) : {}), e) t.options[i] = e[i]; return t.options } function p(t, e, i) { var n, o = []; for (n in t) o.push(encodeURIComponent(i ? n.toUpperCase() : n) + "=" + encodeURIComponent(t[n])); return (e && -1 !== e.indexOf("?") ? "&" : "?") + o.join("&") } var m = /\{ *([\w_ -]+) *\}/g; function f(t, i) { return t.replace(m, function (t, e) { e = i[e]; if (void 0 === e) throw new Error("No value provided for variable " + t); return e = "function" == typeof e ? e(i) : e }) } var g = Array.isArray || function (t) { return "[object Array]" === Object.prototype.toString.call(t) }; function v(t, e) { for (var i = 0; i < t.length; i++)if (t[i] === e) return i; return -1 } var y = "data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs="; function x(t) { return window["webkit" + t] || window["moz" + t] || window["ms" + t] } var w = 0; function b(t) { var e = +new Date, i = Math.max(0, 16 - (e - w)); return w = e + i, window.setTimeout(t, i) } var P = window.requestAnimationFrame || x("RequestAnimationFrame") || b, T = window.cancelAnimationFrame || x("CancelAnimationFrame") || x("CancelRequestAnimationFrame") || function (t) { window.clearTimeout(t) }; function z(t, e, i) { if (!i || P !== b) return P.call(window, a(t, e)); t.call(e) } function S(t) { t && T.call(window, t) } var M = { __proto__: null, extend: l, create: s, bind: a, get lastId() { return i }, stamp: h, throttle: n, wrapNum: o, falseFn: c, formatNum: r, trim: u, splitWords: d, setOptions: _, getParamString: p, template: f, isArray: g, indexOf: v, emptyImageUrl: y, requestFn: P, cancelFn: T, requestAnimFrame: z, cancelAnimFrame: S }; function C() { } C.extend = function (t) { function e() { _(this), this.initialize && this.initialize.apply(this, arguments), this.callInitHooks() } var i, n = e.__super__ = this.prototype, o = s(n); for (i in (o.constructor = e).prototype = o, this) Object.prototype.hasOwnProperty.call(this, i) && "prototype" !== i && "__super__" !== i && (e[i] = this[i]); return t.statics && l(e, t.statics), t.includes && (function (t) { if ("undefined" != typeof L && L && L.Mixin) { t = g(t) ? t : [t]; for (var e = 0; e < t.length; e++)t[e] === L.Mixin.Events && console.warn("Deprecated include of L.Mixin.Events: this property will be removed in future releases, please inherit from L.Evented instead.", (new Error).stack) } }(t.includes), l.apply(null, [o].concat(t.includes))), l(o, t), delete o.statics, delete o.includes, o.options && (o.options = n.options ? s(n.options) : {}, l(o.options, t.options)), o._initHooks = [], o.callInitHooks = function () { if (!this._initHooksCalled) { n.callInitHooks && n.callInitHooks.call(this), this._initHooksCalled = !0; for (var t = 0, e = o._initHooks.length; t < e; t++)o._initHooks[t].call(this) } }, e }, C.include = function (t) { var e = this.prototype.options; return l(this.prototype, t), t.options && (this.prototype.options = e, this.mergeOptions(t.options)), this }, C.mergeOptions = function (t) { return l(this.prototype.options, t), this }, C.addInitHook = function (t) { var e = Array.prototype.slice.call(arguments, 1), i = "function" == typeof t ? t : function () { this[t].apply(this, e) }; return this.prototype._initHooks = this.prototype._initHooks || [], this.prototype._initHooks.push(i), this }; var E = { on: function (t, e, i) { if ("object" == typeof t) for (var n in t) this._on(n, t[n], e); else for (var o = 0, s = (t = d(t)).length; o < s; o++)this._on(t[o], e, i); return this }, off: function (t, e, i) { if (arguments.length) if ("object" == typeof t) for (var n in t) this._off(n, t[n], e); else { t = d(t); for (var o = 1 === arguments.length, s = 0, r = t.length; s < r; s++)o ? this._off(t[s]) : this._off(t[s], e, i) } else delete this._events; return this }, _on: function (t, e, i, n) { "function" == typeof e ? !1 === this._listens(t, e, i) && (i = { fn: e, ctx: i = i === this ? void 0 : i }, n && (i.once = !0), this._events = this._events || {}, this._events[t] = this._events[t] || [], this._events[t].push(i)) : console.warn("wrong listener type: " + typeof e) }, _off: function (t, e, i) { var n, o, s, r; if (this._events && (n = this._events[t])) if (1 !== arguments.length) "function" == typeof e ? !1 !== (r = this._listens(t, e, i)) && (i = n[r], this._firingCount && (i.fn = c, this._events[t] = n = n.slice()), n.splice(r, 1)) : console.warn("wrong listener type: " + typeof e); else { if (this._firingCount) for (o = 0, s = n.length; o < s; o++)n[o].fn = c; delete this._events[t] } }, fire: function (t, e, i) { if (!this.listens(t, i)) return this; var n = l({}, e, { type: t, target: this, sourceTarget: e && e.sourceTarget || this }); if (this._events) { var o = this._events[t]; if (o) { this._firingCount = this._firingCount + 1 || 1; for (var s = 0, r = o.length; s < r; s++){ var a = o[s], h = a.fn; a.once && this.off(t, h, a.ctx), h.call(a.ctx || this, n) } this._firingCount-- } } return i && this._propagateEvent(n), this }, listens: function (t, e, i, n) { "string" != typeof t && console.warn('"string" type argument expected'); var o = e; "function" != typeof e && (n = !!e, i = o = void 0); var s = this._events && this._events[t]; if (s && s.length && !1 !== this._listens(t, o, i)) return !0; if (n) for (var r in this._eventParents) if (this._eventParents[r].listens(t, e, i, n)) return !0; return !1 }, _listens: function (t, e, i) { if (!this._events) return !1; var n = this._events[t] || []; if (!e) return !!n.length; i === this && (i = void 0); for (var o = 0, s = n.length; o < s; o++)if (n[o].fn === e && n[o].ctx === i) return o; return !1 }, once: function (t, e, i) { if ("object" == typeof t) for (var n in t) this._on(n, t[n], e, !0); else for (var o = 0, s = (t = d(t)).length; o < s; o++)this._on(t[o], e, i, !0); return this }, addEventParent: function (t) { return this._eventParents = this._eventParents || {}, this._eventParents[h(t)] = t, this }, removeEventParent: function (t) { return this._eventParents && delete this._eventParents[h(t)], this }, _propagateEvent: function (t) { for (var e in this._eventParents) this._eventParents[e].fire(t.type, l({ layer: t.target, propagatedFrom: t.target }, t), !0) } }; E.addEventListener = E.on, E.removeEventListener = E.clearAllEventListeners = E.off, E.addOneTimeEventListener = E.once, E.fireEvent = E.fire, E.hasEventListeners = E.listens; var k = C.extend(E); function Z(t, e, i) { this.x = i ? Math.round(t) : t, this.y = i ? Math.round(e) : e } var A = Math.trunc || function (t) { return 0 < t ? Math.floor(t) : Math.ceil(t) }; function O(t, e, i) { return t instanceof Z ? t : g(t) ? new Z(t[0], t[1]) : null == t ? t : "object" == typeof t && "x" in t && "y" in t ? new Z(t.x, t.y) : new Z(t, e, i) } function I(t, e) { if (t) for (var i = e ? [t, e] : t, n = 0, o = i.length; n < o; n++)this.extend(i[n]) } function B(t, e) { return !t || t instanceof I ? t : new I(t, e) } function N(t, e) { if (t) for (var i = e ? [t, e] : t, n = 0, o = i.length; n < o; n++)this.extend(i[n]) } function D(t, e) { return t instanceof N ? t : new N(t, e) } function R(t, e, i) { if (isNaN(t) || isNaN(e)) throw new Error("Invalid LatLng object: (" + t + ", " + e + ")"); this.lat = +t, this.lng = +e, void 0 !== i && (this.alt = +i) } function F(t, e, i) { return t instanceof R ? t : g(t) && "object" != typeof t[0] ? 3 === t.length ? new R(t[0], t[1], t[2]) : 2 === t.length ? new R(t[0], t[1]) : null : null == t ? t : "object" == typeof t && "lat" in t ? new R(t.lat, "lng" in t ? t.lng : t.lon, t.alt) : void 0 === e ? null : new R(t, e, i) } Z.prototype = { clone: function () { return new Z(this.x, this.y) }, add: function (t) { return this.clone()._add(O(t)) }, _add: function (t) { return this.x += t.x, this.y += t.y, this }, subtract: function (t) { return this.clone()._subtract(O(t)) }, _subtract: function (t) { return this.x -= t.x, this.y -= t.y, this }, divideBy: function (t) { return this.clone()._divideBy(t) }, _divideBy: function (t) { return this.x /= t, this.y /= t, this }, multiplyBy: function (t) { return this.clone()._multiplyBy(t) }, _multiplyBy: function (t) { return this.x *= t, this.y *= t, this }, scaleBy: function (t) { return new Z(this.x * t.x, this.y * t.y) }, unscaleBy: function (t) { return new Z(this.x / t.x, this.y / t.y) }, round: function () { return this.clone()._round() }, _round: function () { return this.x = Math.round(this.x), this.y = Math.round(this.y), this }, floor: function () { return this.clone()._floor() }, _floor: function () { return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this }, ceil: function () { return this.clone()._ceil() }, _ceil: function () { return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this }, trunc: function () { return this.clone()._trunc() }, _trunc: function () { return this.x = A(this.x), this.y = A(this.y), this }, distanceTo: function (t) { var e = (t = O(t)).x - this.x, t = t.y - this.y; return Math.sqrt(e * e + t * t) }, equals: function (t) { return (t = O(t)).x === this.x && t.y === this.y }, contains: function (t) { return t = O(t), Math.abs(t.x) <= Math.abs(this.x) && Math.abs(t.y) <= Math.abs(this.y) }, toString: function () { return "Point(" + r(this.x) + ", " + r(this.y) + ")" } }, I.prototype = { extend: function (t) { var e, i; if (!t) return this; if (t instanceof Z || "number" == typeof t[0] || "x" in t) e = i = O(t); else if (e = (t = B(t)).min, i = t.max, !e || !i) return this; return this.min || this.max ? (this.min.x = Math.min(e.x, this.min.x), this.max.x = Math.max(i.x, this.max.x), this.min.y = Math.min(e.y, this.min.y), this.max.y = Math.max(i.y, this.max.y)) : (this.min = e.clone(), this.max = i.clone()), this }, getCenter: function (t) { return O((this.min.x + this.max.x) / 2, (this.min.y + this.max.y) / 2, t) }, getBottomLeft: function () { return O(this.min.x, this.max.y) }, getTopRight: function () { return O(this.max.x, this.min.y) }, getTopLeft: function () { return this.min }, getBottomRight: function () { return this.max }, getSize: function () { return this.max.subtract(this.min) }, contains: function (t) { var e, i; return (t = ("number" == typeof t[0] || t instanceof Z ? O : B)(t)) instanceof I ? (e = t.min, i = t.max) : e = i = t, e.x >= this.min.x && i.x <= this.max.x && e.y >= this.min.y && i.y <= this.max.y }, intersects: function (t) { t = B(t); var e = this.min, i = this.max, n = t.min, o = t.max, t = o.x >= e.x && n.x <= i.x, i = o.y >= e.y && n.y <= i.y; return t && i }, overlaps: function (t) { t = B(t); var e = this.min, i = this.max, n = t.min, o = t.max, t = o.x > e.x && n.x < i.x, i = o.y > e.y && n.y < i.y; return t && i }, isValid: function () { return !(!this.min || !this.max) }, pad: function (t) { var e = this.min, i = this.max, n = Math.abs(e.x - i.x) * t, t = Math.abs(e.y - i.y) * t; return B(O(e.x - n, e.y - t), O(i.x + n, i.y + t)) }, equals: function (t) { return !!t && (t = B(t), this.min.equals(t.getTopLeft()) && this.max.equals(t.getBottomRight())) } }, N.prototype = { extend: function (t) { var e, i, n = this._southWest, o = this._northEast; if (t instanceof R) i = e = t; else { if (!(t instanceof N)) return t ? this.extend(F(t) || D(t)) : this; if (e = t._southWest, i = t._northEast, !e || !i) return this } return n || o ? (n.lat = Math.min(e.lat, n.lat), n.lng = Math.min(e.lng, n.lng), o.lat = Math.max(i.lat, o.lat), o.lng = Math.max(i.lng, o.lng)) : (this._southWest = new R(e.lat, e.lng), this._northEast = new R(i.lat, i.lng)), this }, pad: function (t) { var e = this._southWest, i = this._northEast, n = Math.abs(e.lat - i.lat) * t, t = Math.abs(e.lng - i.lng) * t; return new N(new R(e.lat - n, e.lng - t), new R(i.lat + n, i.lng + t)) }, getCenter: function () { return new R((this._southWest.lat + this._northEast.lat) / 2, (this._southWest.lng + this._northEast.lng) / 2) }, getSouthWest: function () { return this._southWest }, getNorthEast: function () { return this._northEast }, getNorthWest: function () { return new R(this.getNorth(), this.getWest()) }, getSouthEast: function () { return new R(this.getSouth(), this.getEast()) }, getWest: function () { return this._southWest.lng }, getSouth: function () { return this._southWest.lat }, getEast: function () { return this._northEast.lng }, getNorth: function () { return this._northEast.lat }, contains: function (t) { t = ("number" == typeof t[0] || t instanceof R || "lat" in t ? F : D)(t); var e, i, n = this._southWest, o = this._northEast; return t instanceof N ? (e = t.getSouthWest(), i = t.getNorthEast()) : e = i = t, e.lat >= n.lat && i.lat <= o.lat && e.lng >= n.lng && i.lng <= o.lng }, intersects: function (t) { t = D(t); var e = this._southWest, i = this._northEast, n = t.getSouthWest(), o = t.getNorthEast(), t = o.lat >= e.lat && n.lat <= i.lat, i = o.lng >= e.lng && n.lng <= i.lng; return t && i }, overlaps: function (t) { t = D(t); var e = this._southWest, i = this._northEast, n = t.getSouthWest(), o = t.getNorthEast(), t = o.lat > e.lat && n.lat < i.lat, i = o.lng > e.lng && n.lng < i.lng; return t && i }, toBBoxString: function () { return [this.getWest(), this.getSouth(), this.getEast(), this.getNorth()].join(",") }, equals: function (t, e) { return !!t && (t = D(t), this._southWest.equals(t.getSouthWest(), e) && this._northEast.equals(t.getNorthEast(), e)) }, isValid: function () { return !(!this._southWest || !this._northEast) } }; var j = { latLngToPoint: function (t, e) { t = this.projection.project(t), e = this.scale(e); return this.transformation._transform(t, e) }, pointToLatLng: function (t, e) { e = this.scale(e), e = this.transformation.untransform(t, e); return this.projection.unproject(e) }, project: function (t) { return this.projection.project(t) }, unproject: function (t) { return this.projection.unproject(t) }, scale: function (t) { return 256 * Math.pow(2, t) }, zoom: function (t) { return Math.log(t / 256) / Math.LN2 }, getProjectedBounds: function (t) { if (this.infinite) return null; var e = this.projection.bounds, t = this.scale(t); return new I(this.transformation.transform(e.min, t), this.transformation.transform(e.max, t)) }, infinite: !(R.prototype = { equals: function (t, e) { return !!t && (t = F(t), Math.max(Math.abs(this.lat - t.lat), Math.abs(this.lng - t.lng)) <= (void 0 === e ? 1e-9 : e)) }, toString: function (t) { return "LatLng(" + r(this.lat, t) + ", " + r(this.lng, t) + ")" }, distanceTo: function (t) { return W.distance(this, F(t)) }, wrap: function () { return W.wrapLatLng(this) }, toBounds: function (t) { var e = 180 * t / 40075017, t = e / Math.cos(Math.PI / 180 * this.lat); return D([this.lat - e, this.lng - t], [this.lat + e, this.lng + t]) }, clone: function () { return new R(this.lat, this.lng, this.alt) } }), wrapLatLng: function (t) { var e = this.wrapLng ? o(t.lng, this.wrapLng, !0) : t.lng; return new R(this.wrapLat ? o(t.lat, this.wrapLat, !0) : t.lat, e, t.alt) }, wrapLatLngBounds: function (t) { var e = t.getCenter(), i = this.wrapLatLng(e), n = e.lat - i.lat, e = e.lng - i.lng; if (0 == n && 0 == e) return t; i = t.getSouthWest(), t = t.getNorthEast(); return new N(new R(i.lat - n, i.lng - e), new R(t.lat - n, t.lng - e)) } }, W = l({}, j, { wrapLng: [-180, 180], R: 6371e3, distance: function (t, e) { var i = Math.PI / 180, n = t.lat * i, o = e.lat * i, s = Math.sin((e.lat - t.lat) * i / 2), i = Math.sin((e.lng - t.lng) * i / 2), i = s * s + Math.cos(n) * Math.cos(o) * i * i, i = 2 * Math.atan2(Math.sqrt(i), Math.sqrt(1 - i)); return this.R * i } }), H = 6378137, U = { R: H, MAX_LATITUDE: 85.0511287798, project: function (t) { var e = Math.PI / 180, i = this.MAX_LATITUDE, i = Math.max(Math.min(i, t.lat), -i), i = Math.sin(i * e); return new Z(this.R * t.lng * e, this.R * Math.log((1 + i) / (1 - i)) / 2) }, unproject: function (t) { var e = 180 / Math.PI; return new R((2 * Math.atan(Math.exp(t.y / this.R)) - Math.PI / 2) * e, t.x * e / this.R) }, bounds: new I([-(Tt = H * Math.PI), -Tt], [Tt, Tt]) }; function V(t, e, i, n) { if (g(t)) return this._a = t[0], this._b = t[1], this._c = t[2], void (this._d = t[3]); this._a = t, this._b = e, this._c = i, this._d = n } function q(t, e, i, n) { return new V(t, e, i, n) } V.prototype = { transform: function (t, e) { return this._transform(t.clone(), e) }, _transform: function (t, e) { return t.x = (e = e || 1) * (this._a * t.x + this._b), t.y = e * (this._c * t.y + this._d), t }, untransform: function (t, e) { return new Z((t.x / (e = e || 1) - this._b) / this._a, (t.y / e - this._d) / this._c) } }; var G = l({}, W, { code: "EPSG:3857", projection: U, transformation: q(zt = .5 / (Math.PI * U.R), .5, -zt, .5) }), K = l({}, G, { code: "EPSG:900913" }); function Y(t) { return document.createElementNS("http://www.w3.org/2000/svg", t) } function X(t, e) { for (var i, n, o, s, r = "", a = 0, h = t.length; a < h; a++){ for (i = 0, n = (o = t[a]).length; i < n; i++)r += (i ? "L" : "M") + (s = o[i]).x + " " + s.y; r += e ? Ct.svg ? "z" : "x" : "" } return r || "M0 0" } var J = document.documentElement.style, $ = "ActiveXObject" in window, Q = $ && !document.addEventListener, tt = "msLaunchUri" in navigator && !("documentMode" in document), et = Mt("webkit"), it = Mt("android"), nt = Mt("android 2") || Mt("android 3"), ot = parseInt(/WebKit\/([0-9]+)|$/.exec(navigator.userAgent)[1], 10), st = it && Mt("Google") && ot < 537 && !("AudioNode" in window), rt = !!window.opera, at = !tt && Mt("chrome"), ht = Mt("gecko") && !et && !rt && !$, lt = !at && Mt("safari"), ct = Mt("phantom"), ut = "OTransition" in J, dt = 0 === navigator.platform.indexOf("Win"), _t = $ && "transition" in J, pt = "WebKitCSSMatrix" in window && "m11" in new window.WebKitCSSMatrix && !nt, mt = "MozPerspective" in J, ft = !window.L_DISABLE_3D && (_t || pt || mt) && !ut && !ct, gt = "undefined" != typeof orientation || Mt("mobile"), vt = gt && et, yt = gt && pt, xt = !window.PointerEvent && window.MSPointerEvent, wt = !(!window.PointerEvent && !xt), bt = "ontouchstart" in window || !!window.TouchEvent, Lt = !window.L_NO_TOUCH && (bt || wt), Pt = gt && rt, H = gt && ht, Tt = 1 < (window.devicePixelRatio || window.screen.deviceXDPI / window.screen.logicalXDPI), zt = function () { var t = !1; try { var e = Object.defineProperty({}, "passive", { get: function () { t = !0 } }); window.addEventListener("testPassiveEventSupport", c, e), window.removeEventListener("testPassiveEventSupport", c, e) } catch (t) { } return t }(), ot = !!document.createElement("canvas").getContext, J = !(!document.createElementNS || !Y("svg").createSVGRect), St = !!J && ((St = document.createElement("div")).innerHTML = "<svg/>", "http://www.w3.org/2000/svg" === (St.firstChild && St.firstChild.namespaceURI)); function Mt(t) { return 0 <= navigator.userAgent.toLowerCase().indexOf(t) } var Ct = { ie: $, ielt9: Q, edge: tt, webkit: et, android: it, android23: nt, androidStock: st, opera: rt, chrome: at, gecko: ht, safari: lt, phantom: ct, opera12: ut, win: dt, ie3d: _t, webkit3d: pt, gecko3d: mt, any3d: ft, mobile: gt, mobileWebkit: vt, mobileWebkit3d: yt, msPointer: xt, pointer: wt, touch: Lt, touchNative: bt, mobileOpera: Pt, mobileGecko: H, retina: Tt, passiveEvents: zt, canvas: ot, svg: J, vml: !J && function () { try { var t = document.createElement("div"); t.innerHTML = '<v:shape adj="1"/>'; var e = t.firstChild; return e.style.behavior = "url(#default#VML)", e && "object" == typeof e.adj } catch (t) { return !1 } }(), inlineSvg: St, mac: 0 === navigator.platform.indexOf("Mac"), linux: 0 === navigator.platform.indexOf("Linux") }, Et = Ct.msPointer ? "MSPointerDown" : "pointerdown", kt = Ct.msPointer ? "MSPointerMove" : "pointermove", Zt = Ct.msPointer ? "MSPointerUp" : "pointerup", At = Ct.msPointer ? "MSPointerCancel" : "pointercancel", Ot = { touchstart: Et, touchmove: kt, touchend: Zt, touchcancel: At }, It = { touchstart: function (t, e) { e.MSPOINTER_TYPE_TOUCH && e.pointerType === e.MSPOINTER_TYPE_TOUCH && Ae(e); Wt(t, e) }, touchmove: Wt, touchend: Wt, touchcancel: Wt }, Bt = {}, Nt = !1; function Dt(t, e, i) { return "touchstart" === e && (Nt || (document.addEventListener(Et, Rt, !0), document.addEventListener(kt, Ft, !0), document.addEventListener(Zt, jt, !0), document.addEventListener(At, jt, !0), Nt = !0)), It[e] ? (i = It[e].bind(this, i), t.addEventListener(Ot[e], i, !1), i) : (console.warn("wrong event specified:", e), c) } function Rt(t) { Bt[t.pointerId] = t } function Ft(t) { Bt[t.pointerId] && (Bt[t.pointerId] = t) } function jt(t) { delete Bt[t.pointerId] } function Wt(t, e) { if (e.pointerType !== (e.MSPOINTER_TYPE_MOUSE || "mouse")) { for (var i in e.touches = [], Bt) e.touches.push(Bt[i]); e.changedTouches = [e], t(e) } } var Ht = 200; function Ut(t, i) { t.addEventListener("dblclick", i); var n, o = 0; function e(t) { var e; 1 === t.detail ? "mouse" === t.pointerType || t.sourceCapabilities && !t.sourceCapabilities.firesTouchEvents || ((e = Ie(t)).some(function (t) { return t instanceof HTMLLabelElement && t.attributes.for }) && !e.some(function (t) { return t instanceof HTMLInputElement || t instanceof HTMLSelectElement }) || ((e = Date.now()) - o <= Ht ? 2 === ++n && i(function (t) { var e, i, n = {}; for (i in t) e = t[i], n[i] = e && e.bind ? e.bind(t) : e; return (t = n).type = "dblclick", n.detail = 2, n.isTrusted = !1, n._simulated = !0, n }(t)) : n = 1, o = e)) : n = t.detail } return t.addEventListener("click", e), { dblclick: i, simDblclick: e } } var Vt, qt, Gt, Kt, Yt, Xt, Jt = _e(["transform", "webkitTransform", "OTransform", "MozTransform", "msTransform"]), $t = _e(["webkitTransition", "transition", "OTransition", "MozTransition", "msTransition"]), Qt = "webkitTransition" === $t || "OTransition" === $t ? $t + "End" : "transitionend"; function te(t) { return "string" == typeof t ? document.getElementById(t) : t } function ee(t, e) { var i = t.style[e] || t.currentStyle && t.currentStyle[e]; return "auto" === (i = (!i || "auto" === i) && document.defaultView ? (t = document.defaultView.getComputedStyle(t, null)) ? t[e] : null : i) ? null : i } function ie(t, e, i) { t = document.createElement(t); return t.className = e || "", i && i.appendChild(t), t } function ne(t) { var e = t.parentNode; e && e.removeChild(t) } function oe(t) { for (; t.firstChild;)t.removeChild(t.firstChild) } function se(t) { var e = t.parentNode; e && e.lastChild !== t && e.appendChild(t) } function re(t) { var e = t.parentNode; e && e.firstChild !== t && e.insertBefore(t, e.firstChild) } function ae(t, e) { if (void 0 !== t.classList) return t.classList.contains(e); t = ue(t); return 0 < t.length && new RegExp("(^|\\s)" + e + "(\\s|$)").test(t) } function he(t, e) { var i; if (void 0 !== t.classList) for (var n = d(e), o = 0, s = n.length; o < s; o++)t.classList.add(n[o]); else ae(t, e) || ce(t, ((i = ue(t)) ? i + " " : "") + e) } function le(t, e) { void 0 !== t.classList ? t.classList.remove(e) : ce(t, u((" " + ue(t) + " ").replace(" " + e + " ", " "))) } function ce(t, e) { void 0 === t.className.baseVal ? t.className = e : t.className.baseVal = e } function ue(t) { return void 0 === (t = t.correspondingElement ? t.correspondingElement : t).className.baseVal ? t.className : t.className.baseVal } function de(t, e) { "opacity" in t.style ? t.style.opacity = e : "filter" in t.style && function (t, e) { var i = !1, n = "DXImageTransform.Microsoft.Alpha"; try { i = t.filters.item(n) } catch (t) { if (1 === e) return } e = Math.round(100 * e), i ? (i.Enabled = 100 !== e, i.Opacity = e) : t.style.filter += " progid:" + n + "(opacity=" + e + ")" }(t, e) } function _e(t) { for (var e = document.documentElement.style, i = 0; i < t.length; i++)if (t[i] in e) return t[i]; return !1 } function pe(t, e, i) { e = e || new Z(0, 0); t.style[Jt] = (Ct.ie3d ? "translate(" + e.x + "px," + e.y + "px)" : "translate3d(" + e.x + "px," + e.y + "px,0)") + (i ? " scale(" + i + ")" : "") } function me(t, e) { t._leaflet_pos = e, Ct.any3d ? pe(t, e) : (t.style.left = e.x + "px", t.style.top = e.y + "px") } function fe(t) { return t._leaflet_pos || new Z(0, 0) } function ge() { Le(window, "dragstart", Ae) } function ve() { Te(window, "dragstart", Ae) } function ye(t) { for (; -1 === t.tabIndex;)t = t.parentNode; t.style && (xe(), Xt = (Yt = t).style.outlineStyle, t.style.outlineStyle = "none", Le(window, "keydown", xe)) } function xe() { Yt && (Yt.style.outlineStyle = Xt, Xt = Yt = void 0, Te(window, "keydown", xe)) } function we(t) { for (; !((t = t.parentNode).offsetWidth && t.offsetHeight || t === document.body);); return t } function be(t) { var e = t.getBoundingClientRect(); return { x: e.width / t.offsetWidth || 1, y: e.height / t.offsetHeight || 1, boundingClientRect: e } } Kt = "onselectstart" in document ? (Gt = function () { Le(window, "selectstart", Ae) }, function () { Te(window, "selectstart", Ae) }) : (qt = _e(["userSelect", "WebkitUserSelect", "OUserSelect", "MozUserSelect", "msUserSelect"]), Gt = function () { var t; qt && (t = document.documentElement.style, Vt = t[qt], t[qt] = "none") }, function () { qt && (document.documentElement.style[qt] = Vt, Vt = void 0) }); vt = { __proto__: null, TRANSFORM: Jt, TRANSITION: $t, TRANSITION_END: Qt, get: te, getStyle: ee, create: ie, remove: ne, empty: oe, toFront: se, toBack: re, hasClass: ae, addClass: he, removeClass: le, setClass: ce, getClass: ue, setOpacity: de, testProp: _e, setTransform: pe, setPosition: me, getPosition: fe, get disableTextSelection() { return Gt }, get enableTextSelection() { return Kt }, disableImageDrag: ge, enableImageDrag: ve, preventOutline: ye, restoreOutline: xe, getSizedParentNode: we, getScale: be }; function Le(t, e, i, n) { if (e && "object" == typeof e) for (var o in e) Me(t, o, e[o], i); else for (var s = 0, r = (e = d(e)).length; s < r; s++)Me(t, e[s], i, n); return this } var Pe = "_leaflet_events"; function Te(t, e, i, n) { if (1 === arguments.length) ze(t), delete t[Pe]; else if (e && "object" == typeof e) for (var o in e) Ce(t, o, e[o], i); else if (e = d(e), 2 === arguments.length) ze(t, function (t) { return -1 !== v(e, t) }); else for (var s = 0, r = e.length; s < r; s++)Ce(t, e[s], i, n); return this } function ze(t, e) { for (var i in t[Pe]) { var n = i.split(/\d/)[0]; e && !e(n) || Ce(t, n, null, null, i) } } var Se = { mouseenter: "mouseover", mouseleave: "mouseout", wheel: !("onwheel" in window) && "mousewheel" }; function Me(e, t, i, n) { var o = t + h(i) + (n ? "_" + h(n) : ""); if (e[Pe] && e[Pe][o]) return this; var s = function (t) { return i.call(n || e, t || window.event) }, r = s; !Ct.touchNative && Ct.pointer && 0 === t.indexOf("touch") ? s = Dt(e, t, s) : Ct.touch && "dblclick" === t ? s = Ut(e, s) : "addEventListener" in e ? "touchstart" === t || "touchmove" === t || "wheel" === t || "mousewheel" === t ? e.addEventListener(Se[t] || t, s, !!Ct.passiveEvents && { passive: !1 }) : "mouseenter" === t || "mouseleave" === t ? e.addEventListener(Se[t], s = function (t) { t = t || window.event, Re(e, t) && r(t) }, !1) : e.addEventListener(t, r, !1) : e.attachEvent("on" + t, s), e[Pe] = e[Pe] || {}, e[Pe][o] = s } function Ce(t, e, i, n, o) { o = o || e + h(i) + (n ? "_" + h(n) : ""); var s, r, i = t[Pe] && t[Pe][o]; if (!i) return this; !Ct.touchNative && Ct.pointer && 0 === e.indexOf("touch") ? (n = t, r = i, Ot[s = e] ? n.removeEventListener(Ot[s], r, !1) : console.warn("wrong event specified:", s)) : Ct.touch && "dblclick" === e ? (r = i, (s = t).removeEventListener("dblclick", r.dblclick), s.removeEventListener("click", r.simDblclick)) : "removeEventListener" in t ? t.removeEventListener(Se[e] || e, i, !1) : t.detachEvent("on" + e, i), t[Pe][o] = null } function Ee(t) { return t.stopPropagation ? t.stopPropagation() : t.originalEvent ? t.originalEvent._stopped = !0 : t.cancelBubble = !0, this } function ke(t) { return Me(t, "wheel", Ee), this } function Ze(t) { return Le(t, "mousedown touchstart dblclick contextmenu", Ee), t._leaflet_disable_click = !0, this } function Ae(t) { return t.preventDefault ? t.preventDefault() : t.returnValue = !1, this } function Oe(t) { return Ae(t), Ee(t), this } function Ie(t) { if (t.composedPath) return t.composedPath(); for (var e = [], i = t.target; i;)e.push(i), i = i.parentNode; return e } function Be(t, e) { if (!e) return new Z(t.clientX, t.clientY); var i = be(e), n = i.boundingClientRect; return new Z((t.clientX - n.left) / i.x - e.clientLeft, (t.clientY - n.top) / i.y - e.clientTop) } var Ne = Ct.linux && Ct.chrome ? window.devicePixelRatio : Ct.mac ? 3 * window.devicePixelRatio : 0 < window.devicePixelRatio ? 2 * window.devicePixelRatio : 1; function De(t) { return Ct.edge ? t.wheelDeltaY / 2 : t.deltaY && 0 === t.deltaMode ? -t.deltaY / Ne : t.deltaY && 1 === t.deltaMode ? 20 * -t.deltaY : t.deltaY && 2 === t.deltaMode ? 60 * -t.deltaY : t.deltaX || t.deltaZ ? 0 : t.wheelDelta ? (t.wheelDeltaY || t.wheelDelta) / 2 : t.detail && Math.abs(t.detail) < 32765 ? 20 * -t.detail : t.detail ? t.detail / -32765 * 60 : 0 } function Re(t, e) { var i = e.relatedTarget; if (!i) return !0; try { for (; i && i !== t;)i = i.parentNode } catch (t) { return !1 } return i !== t } var yt = { __proto__: null, on: Le, off: Te, stopPropagation: Ee, disableScrollPropagation: ke, disableClickPropagation: Ze, preventDefault: Ae, stop: Oe, getPropagationPath: Ie, getMousePosition: Be, getWheelDelta: De, isExternalTarget: Re, addListener: Le, removeListener: Te }, Fe = k.extend({ run: function (t, e, i, n) { this.stop(), this._el = t, this._inProgress = !0, this._duration = i || .25, this._easeOutPower = 1 / Math.max(n || .5, .2), this._startPos = fe(t), this._offset = e.subtract(this._startPos), this._startTime = +new Date, this.fire("start"), this._animate() }, stop: function () { this._inProgress && (this._step(!0), this._complete()) }, _animate: function () { this._animId = z(this._animate, this), this._step() }, _step: function (t) { var e = +new Date - this._startTime, i = 1e3 * this._duration; e < i ? this._runFrame(this._easeOut(e / i), t) : (this._runFrame(1), this._complete()) }, _runFrame: function (t, e) { t = this._startPos.add(this._offset.multiplyBy(t)); e && t._round(), me(this._el, t), this.fire("step") }, _complete: function () { S(this._animId), this._inProgress = !1, this.fire("end") }, _easeOut: function (t) { return 1 - Math.pow(1 - t, this._easeOutPower) } }), je = k.extend({ options: { crs: G, center: void 0, zoom: void 0, minZoom: void 0, maxZoom: void 0, layers: [], maxBounds: void 0, renderer: void 0, zoomAnimation: !0, zoomAnimationThreshold: 4, fadeAnimation: !0, markerZoomAnimation: !0, transform3DLimit: 8388608, zoomSnap: 1, zoomDelta: 1, trackResize: !0 }, initialize: function (t, e) { e = _(this, e), this._handlers = [], this._layers = {}, this._zoomBoundLayers = {}, this._sizeChanged = !0, this._initContainer(t), this._initLayout(), this._onResize = a(this._onResize, this), this._initEvents(), e.maxBounds && this.setMaxBounds(e.maxBounds), void 0 !== e.zoom && (this._zoom = this._limitZoom(e.zoom)), e.center && void 0 !== e.zoom && this.setView(F(e.center), e.zoom, { reset: !0 }), this.callInitHooks(), this._zoomAnimated = $t && Ct.any3d && !Ct.mobileOpera && this.options.zoomAnimation, this._zoomAnimated && (this._createAnimProxy(), Le(this._proxy, Qt, this._catchTransitionEnd, this)), this._addLayers(this.options.layers) }, setView: function (t, e, i) { if ((e = void 0 === e ? this._zoom : this._limitZoom(e), t = this._limitCenter(F(t), e, this.options.maxBounds), i = i || {}, this._stop(), this._loaded && !i.reset && !0 !== i) && (void 0 !== i.animate && (i.zoom = l({ animate: i.animate }, i.zoom), i.pan = l({ animate: i.animate, duration: i.duration }, i.pan)), this._zoom !== e ? this._tryAnimatedZoom && this._tryAnimatedZoom(t, e, i.zoom) : this._tryAnimatedPan(t, i.pan))) return clearTimeout(this._sizeTimer), this; return this._resetView(t, e, i.pan && i.pan.noMoveStart), this }, setZoom: function (t, e) { return this._loaded ? this.setView(this.getCenter(), t, { zoom: e }) : (this._zoom = t, this) }, zoomIn: function (t, e) { return t = t || (Ct.any3d ? this.options.zoomDelta : 1), this.setZoom(this._zoom + t, e) }, zoomOut: function (t, e) { return t = t || (Ct.any3d ? this.options.zoomDelta : 1), this.setZoom(this._zoom - t, e) }, setZoomAround: function (t, e, i) { var n = this.getZoomScale(e), o = this.getSize().divideBy(2), n = (t instanceof Z ? t : this.latLngToContainerPoint(t)).subtract(o).multiplyBy(1 - 1 / n), n = this.containerPointToLatLng(o.add(n)); return this.setView(n, e, { zoom: i }) }, _getBoundsCenterZoom: function (t, e) { e = e || {}, t = t.getBounds ? t.getBounds() : D(t); var i = O(e.paddingTopLeft || e.padding || [0, 0]), n = O(e.paddingBottomRight || e.padding || [0, 0]), o = this.getBoundsZoom(t, !1, i.add(n)); if ((o = "number" == typeof e.maxZoom ? Math.min(e.maxZoom, o) : o) === 1 / 0) return { center: t.getCenter(), zoom: o }; n = n.subtract(i).divideBy(2), i = this.project(t.getSouthWest(), o), t = this.project(t.getNorthEast(), o); return { center: this.unproject(i.add(t).divideBy(2).add(n), o), zoom: o } }, fitBounds: function (t, e) { if (!(t = D(t)).isValid()) throw new Error("Bounds are not valid."); t = this._getBoundsCenterZoom(t, e); return this.setView(t.center, t.zoom, e) }, fitWorld: function (t) { return this.fitBounds([[-90, -180], [90, 180]], t) }, panTo: function (t, e) { return this.setView(t, this._zoom, { pan: e }) }, panBy: function (t, e) { return e = e || {}, (t = O(t).round()).x || t.y ? (!0 === e.animate || this.getSize().contains(t) ? (this._panAnim || (this._panAnim = new Fe, this._panAnim.on({ step: this._onPanTransitionStep, end: this._onPanTransitionEnd }, this)), e.noMoveStart || this.fire("movestart"), !1 !== e.animate ? (he(this._mapPane, "leaflet-pan-anim"), i = this._getMapPanePos().subtract(t).round(), this._panAnim.run(this._mapPane, i, e.duration || .25, e.easeLinearity)) : (this._rawPanBy(t), this.fire("move").fire("moveend"))) : this._resetView(this.unproject(this.project(this.getCenter()).add(t)), this.getZoom()), this) : this.fire("moveend"); var i }, flyTo: function (n, o, t) { if (!1 === (t = t || {}).animate || !Ct.any3d) return this.setView(n, o, t); this._stop(); var s = this.project(this.getCenter()), r = this.project(n), e = this.getSize(), a = this._zoom; n = F(n), o = void 0 === o ? a : o; var h = Math.max(e.x, e.y), i = h * this.getZoomScale(a, o), l = r.distanceTo(s) || 1, c = 1.42, u = c * c; function d(t) { t = (i * i - h * h + (t ? -1 : 1) * u * u * l * l) / (2 * (t ? i : h) * u * l), t = Math.sqrt(t * t + 1) - t; return t < 1e-9 ? -18 : Math.log(t) } function _(t) { return (Math.exp(t) - Math.exp(-t)) / 2 } function p(t) { return (Math.exp(t) + Math.exp(-t)) / 2 } var m = d(0); function f(t) { return h * (p(m) * (_(t = m + c * t) / p(t)) - _(m)) / u } var g = Date.now(), v = (d(1) - m) / c, y = t.duration ? 1e3 * t.duration : 1e3 * v * .8; return this._moveStart(!0, t.noMoveStart), function t() { var e = (Date.now() - g) / y, i = (1 - Math.pow(1 - e, 1.5)) * v; e <= 1 ? (this._flyToFrame = z(t, this), this._move(this.unproject(s.add(r.subtract(s).multiplyBy(f(i) / l)), a), this.getScaleZoom(h / (h * (p(m) / p(m + c * i))), a), { flyTo: !0 })) : this._move(n, o)._moveEnd(!0) }.call(this), this }, flyToBounds: function (t, e) { t = this._getBoundsCenterZoom(t, e); return this.flyTo(t.center, t.zoom, e) }, setMaxBounds: function (t) { return t = D(t), this.listens("moveend", this._panInsideMaxBounds) && this.off("moveend", this._panInsideMaxBounds), t.isValid() ? (this.options.maxBounds = t, this._loaded && this._panInsideMaxBounds(), this.on("moveend", this._panInsideMaxBounds)) : (this.options.maxBounds = null, this) }, setMinZoom: function (t) { var e = this.options.minZoom; return this.options.minZoom = t, this._loaded && e !== t && (this.fire("zoomlevelschange"), this.getZoom() < this.options.minZoom) ? this.setZoom(t) : this }, setMaxZoom: function (t) { var e = this.options.maxZoom; return this.options.maxZoom = t, this._loaded && e !== t && (this.fire("zoomlevelschange"), this.getZoom() > this.options.maxZoom) ? this.setZoom(t) : this }, panInsideBounds: function (t, e) { this._enforcingBounds = !0; var i = this.getCenter(), t = this._limitCenter(i, this._zoom, D(t)); return i.equals(t) || this.panTo(t, e), this._enforcingBounds = !1, this }, panInside: function (t, e) { var i = O((e = e || {}).paddingTopLeft || e.padding || [0, 0]), n = O(e.paddingBottomRight || e.padding || [0, 0]), o = this.project(this.getCenter()), s = this.project(t), t = this.getPixelBounds(), i = B([t.min.add(i), t.max.subtract(n)]), t = i.getSize(); return i.contains(s) || (this._enforcingBounds = !0, n = s.subtract(i.getCenter()), t = i.extend(s).getSize().subtract(t), o.x += n.x < 0 ? -t.x : t.x, o.y += n.y < 0 ? -t.y : t.y, this.panTo(this.unproject(o), e), this._enforcingBounds = !1), this }, invalidateSize: function (t) { if (!this._loaded) return this; t = l({ animate: !1, pan: !0 }, !0 === t ? { animate: !0 } : t); var e = this.getSize(); this._sizeChanged = !0, this._lastCenter = null; var i = this.getSize(), n = e.divideBy(2).round(), o = i.divideBy(2).round(), o = n.subtract(o); return o.x || o.y ? (t.animate && t.pan ? this.panBy(o) : (t.pan && this._rawPanBy(o), this.fire("move"), t.debounceMoveend ? (clearTimeout(this._sizeTimer), this._sizeTimer = setTimeout(a(this.fire, this, "moveend"), 200)) : this.fire("moveend")), this.fire("resize", { oldSize: e, newSize: i })) : this }, stop: function () { return this.setZoom(this._limitZoom(this._zoom)), this.options.zoomSnap || this.fire("viewreset"), this._stop() }, locate: function (t) { if (t = this._locateOptions = l({ timeout: 1e4, watch: !1 }, t), !("geolocation" in navigator)) return this._handleGeolocationError({ code: 0, message: "Geolocation not supported." }), this; var e = a(this._handleGeolocationResponse, this), i = a(this._handleGeolocationError, this); return t.watch ? this._locationWatchId = navigator.geolocation.watchPosition(e, i, t) : navigator.geolocation.getCurrentPosition(e, i, t), this }, stopLocate: function () { return navigator.geolocation && navigator.geolocation.clearWatch && navigator.geolocation.clearWatch(this._locationWatchId), this._locateOptions && (this._locateOptions.setView = !1), this }, _handleGeolocationError: function (t) { var e; this._container._leaflet_id && (e = t.code, t = t.message || (1 === e ? "permission denied" : 2 === e ? "position unavailable" : "timeout"), this._locateOptions.setView && !this._loaded && this.fitWorld(), this.fire("locationerror", { code: e, message: "Geolocation error: " + t + "." })) }, _handleGeolocationResponse: function (t) { if (this._container._leaflet_id) { var e, i = new R(t.coords.latitude, t.coords.longitude), n = i.toBounds(2 * t.coords.accuracy), o = this._locateOptions; o.setView && (e = this.getBoundsZoom(n), this.setView(i, o.maxZoom ? Math.min(e, o.maxZoom) : e)); var s, r = { latlng: i, bounds: n, timestamp: t.timestamp }; for (s in t.coords) "number" == typeof t.coords[s] && (r[s] = t.coords[s]); this.fire("locationfound", r) } }, addHandler: function (t, e) { if (!e) return this; e = this[t] = new e(this); return this._handlers.push(e), this.options[t] && e.enable(), this }, remove: function () { if (this._initEvents(!0), this.options.maxBounds && this.off("moveend", this._panInsideMaxBounds), this._containerId !== this._container._leaflet_id) throw new Error("Map container is being reused by another instance"); try { delete this._container._leaflet_id, delete this._containerId } catch (t) { this._container._leaflet_id = void 0, this._containerId = void 0 } for (var t in void 0 !== this._locationWatchId && this.stopLocate(), this._stop(), ne(this._mapPane), this._clearControlPos && this._clearControlPos(), this._resizeRequest && (S(this._resizeRequest), this._resizeRequest = null), this._clearHandlers(), this._loaded && this.fire("unload"), this._layers) this._layers[t].remove(); for (t in this._panes) ne(this._panes[t]); return this._layers = [], this._panes = [], delete this._mapPane, delete this._renderer, this }, createPane: function (t, e) { e = ie("div", "leaflet-pane" + (t ? " leaflet-" + t.replace("Pane", "") + "-pane" : ""), e || this._mapPane); return t && (this._panes[t] = e), e }, getCenter: function () { return this._checkIfLoaded(), this._lastCenter && !this._moved() ? this._lastCenter.clone() : this.layerPointToLatLng(this._getCenterLayerPoint()) }, getZoom: function () { return this._zoom }, getBounds: function () { var t = this.getPixelBounds(); return new N(this.unproject(t.getBottomLeft()), this.unproject(t.getTopRight())) }, getMinZoom: function () { return void 0 === this.options.minZoom ? this._layersMinZoom || 0 : this.options.minZoom }, getMaxZoom: function () { return void 0 === this.options.maxZoom ? void 0 === this._layersMaxZoom ? 1 / 0 : this._layersMaxZoom : this.options.maxZoom }, getBoundsZoom: function (t, e, i) { t = D(t), i = O(i || [0, 0]); var n = this.getZoom() || 0, o = this.getMinZoom(), s = this.getMaxZoom(), r = t.getNorthWest(), a = t.getSouthEast(), t = this.getSize().subtract(i), i = B(this.project(a, n), this.project(r, n)).getSize(), a = Ct.any3d ? this.options.zoomSnap : 1, r = t.x / i.x, i = t.y / i.y, i = e ? Math.max(r, i) : Math.min(r, i), n = this.getScaleZoom(i, n); return a && (n = Math.round(n / (a / 100)) * (a / 100), n = e ? Math.ceil(n / a) * a : Math.floor(n / a) * a), Math.max(o, Math.min(s, n)) }, getSize: function () { return this._size && !this._sizeChanged || (this._size = new Z(this._container.clientWidth || 0, this._container.clientHeight || 0), this._sizeChanged = !1), this._size.clone() }, getPixelBounds: function (t, e) { e = this._getTopLeftPoint(t, e); return new I(e, e.add(this.getSize())) }, getPixelOrigin: function () { return this._checkIfLoaded(), this._pixelOrigin }, getPixelWorldBounds: function (t) { return this.options.crs.getProjectedBounds(void 0 === t ? this.getZoom() : t) }, getPane: function (t) { return "string" == typeof t ? this._panes[t] : t }, getPanes: function () { return this._panes }, getContainer: function () { return this._container }, getZoomScale: function (t, e) { var i = this.options.crs; return e = void 0 === e ? this._zoom : e, i.scale(t) / i.scale(e) }, getScaleZoom: function (t, e) { var i = this.options.crs; e = void 0 === e ? this._zoom : e; e = i.zoom(t * i.scale(e)); return isNaN(e) ? 1 / 0 : e }, project: function (t, e) { return e = void 0 === e ? this._zoom : e, this.options.crs.latLngToPoint(F(t), e) }, unproject: function (t, e) { return e = void 0 === e ? this._zoom : e, this.options.crs.pointToLatLng(O(t), e) }, layerPointToLatLng: function (t) { t = O(t).add(this.getPixelOrigin()); return this.unproject(t) }, latLngToLayerPoint: function (t) { return this.project(F(t))._round()._subtract(this.getPixelOrigin()) }, wrapLatLng: function (t) { return this.options.crs.wrapLatLng(F(t)) }, wrapLatLngBounds: function (t) { return this.options.crs.wrapLatLngBounds(D(t)) }, distance: function (t, e) { return this.options.crs.distance(F(t), F(e)) }, containerPointToLayerPoint: function (t) { return O(t).subtract(this._getMapPanePos()) }, layerPointToContainerPoint: function (t) { return O(t).add(this._getMapPanePos()) }, containerPointToLatLng: function (t) { t = this.containerPointToLayerPoint(O(t)); return this.layerPointToLatLng(t) }, latLngToContainerPoint: function (t) { return this.layerPointToContainerPoint(this.latLngToLayerPoint(F(t))) }, mouseEventToContainerPoint: function (t) { return Be(t, this._container) }, mouseEventToLayerPoint: function (t) { return this.containerPointToLayerPoint(this.mouseEventToContainerPoint(t)) }, mouseEventToLatLng: function (t) { return this.layerPointToLatLng(this.mouseEventToLayerPoint(t)) }, _initContainer: function (t) { t = this._container = te(t); if (!t) throw new Error("Map container not found."); if (t._leaflet_id) throw new Error("Map container is already initialized."); Le(t, "scroll", this._onScroll, this), this._containerId = h(t) }, _initLayout: function () { var t = this._container; this._fadeAnimated = this.options.fadeAnimation && Ct.any3d, he(t, "leaflet-container" + (Ct.touch ? " leaflet-touch" : "") + (Ct.retina ? " leaflet-retina" : "") + (Ct.ielt9 ? " leaflet-oldie" : "") + (Ct.safari ? " leaflet-safari" : "") + (this._fadeAnimated ? " leaflet-fade-anim" : "")); var e = ee(t, "position"); "absolute" !== e && "relative" !== e && "fixed" !== e && "sticky" !== e && (t.style.position = "relative"), this._initPanes(), this._initControlPos && this._initControlPos() }, _initPanes: function () { var t = this._panes = {}; this._paneRenderers = {}, this._mapPane = this.createPane("mapPane", this._container), me(this._mapPane, new Z(0, 0)), this.createPane("tilePane"), this.createPane("overlayPane"), this.createPane("shadowPane"), this.createPane("markerPane"), this.createPane("tooltipPane"), this.createPane("popupPane"), this.options.markerZoomAnimation || (he(t.markerPane, "leaflet-zoom-hide"), he(t.shadowPane, "leaflet-zoom-hide")) }, _resetView: function (t, e, i) { me(this._mapPane, new Z(0, 0)); var n = !this._loaded; this._loaded = !0, e = this._limitZoom(e), this.fire("viewprereset"); var o = this._zoom !== e; this._moveStart(o, i)._move(t, e)._moveEnd(o), this.fire("viewreset"), n && this.fire("load") }, _moveStart: function (t, e) { return t && this.fire("zoomstart"), e || this.fire("movestart"), this }, _move: function (t, e, i, n) { void 0 === e && (e = this._zoom); var o = this._zoom !== e; return this._zoom = e, this._lastCenter = t, this._pixelOrigin = this._getNewPixelOrigin(t), n ? i && i.pinch && this.fire("zoom", i) : ((o || i && i.pinch) && this.fire("zoom", i), this.fire("move", i)), this }, _moveEnd: function (t) { return t && this.fire("zoomend"), this.fire("moveend") }, _stop: function () { return S(this._flyToFrame), this._panAnim && this._panAnim.stop(), this }, _rawPanBy: function (t) { me(this._mapPane, this._getMapPanePos().subtract(t)) }, _getZoomSpan: function () { return this.getMaxZoom() - this.getMinZoom() }, _panInsideMaxBounds: function () { this._enforcingBounds || this.panInsideBounds(this.options.maxBounds) }, _checkIfLoaded: function () { if (!this._loaded) throw new Error("Set map center and zoom first.") }, _initEvents: function (t) { this._targets = {}; var e = t ? Te : Le; e((this._targets[h(this._container)] = this)._container, "click dblclick mousedown mouseup mouseover mouseout mousemove contextmenu keypress keydown keyup", this._handleDOMEvent, this), this.options.trackResize && e(window, "resize", this._onResize, this), Ct.any3d && this.options.transform3DLimit && (t ? this.off : this.on).call(this, "moveend", this._onMoveEnd) }, _onResize: function () { S(this._resizeRequest), this._resizeRequest = z(function () { this.invalidateSize({ debounceMoveend: !0 }) }, this) }, _onScroll: function () { this._container.scrollTop = 0, this._container.scrollLeft = 0 }, _onMoveEnd: function () { var t = this._getMapPanePos(); Math.max(Math.abs(t.x), Math.abs(t.y)) >= this.options.transform3DLimit && this._resetView(this.getCenter(), this.getZoom()) }, _findEventTargets: function (t, e) { for (var i, n = [], o = "mouseout" === e || "mouseover" === e, s = t.target || t.srcElement, r = !1; s;){ if ((i = this._targets[h(s)]) && ("click" === e || "preclick" === e) && this._draggableMoved(i)) { r = !0; break } if (i && i.listens(e, !0)) { if (o && !Re(s, t)) break; if (n.push(i), o) break } if (s === this._container) break; s = s.parentNode } return n = !(n.length || r || o) && this.listens(e, !0) ? [this] : n }, _isClickDisabled: function (t) { for (; t && t !== this._container;){ if (t._leaflet_disable_click) return !0; t = t.parentNode } }, _handleDOMEvent: function (t) { var e, i = t.target || t.srcElement; !this._loaded || i._leaflet_disable_events || "click" === t.type && this._isClickDisabled(i) || ("mousedown" === (e = t.type) && ye(i), this._fireDOMEvent(t, e)) }, _mouseEvents: ["click", "dblclick", "mouseover", "mouseout", "contextmenu"], _fireDOMEvent: function (t, e, i) { "click" === t.type && ((r = l({}, t)).type = "preclick", this._fireDOMEvent(r, r.type, i)); var n = this._findEventTargets(t, e); if (i) { for (var o = [], s = 0; s < i.length; s++)i[s].listens(e, !0) && o.push(i[s]); n = o.concat(n) } if (n.length) { "contextmenu" === e && Ae(t); var r, a = n[0], h = { originalEvent: t }; for ("keypress" !== t.type && "keydown" !== t.type && "keyup" !== t.type && (r = a.getLatLng && (!a._radius || a._radius <= 10), h.containerPoint = r ? this.latLngToContainerPoint(a.getLatLng()) : this.mouseEventToContainerPoint(t), h.layerPoint = this.containerPointToLayerPoint(h.containerPoint), h.latlng = r ? a.getLatLng() : this.layerPointToLatLng(h.layerPoint)), s = 0; s < n.length; s++)if (n[s].fire(e, h, !0), h.originalEvent._stopped || !1 === n[s].options.bubblingMouseEvents && -1 !== v(this._mouseEvents, e)) return } }, _draggableMoved: function (t) { return (t = t.dragging && t.dragging.enabled() ? t : this).dragging && t.dragging.moved() || this.boxZoom && this.boxZoom.moved() }, _clearHandlers: function () { for (var t = 0, e = this._handlers.length; t < e; t++)this._handlers[t].disable() }, whenReady: function (t, e) { return this._loaded ? t.call(e || this, { target: this }) : this.on("load", t, e), this }, _getMapPanePos: function () { return fe(this._mapPane) || new Z(0, 0) }, _moved: function () { var t = this._getMapPanePos(); return t && !t.equals([0, 0]) }, _getTopLeftPoint: function (t, e) { return (t && void 0 !== e ? this._getNewPixelOrigin(t, e) : this.getPixelOrigin()).subtract(this._getMapPanePos()) }, _getNewPixelOrigin: function (t, e) { var i = this.getSize()._divideBy(2); return this.project(t, e)._subtract(i)._add(this._getMapPanePos())._round() }, _latLngToNewLayerPoint: function (t, e, i) { i = this._getNewPixelOrigin(i, e); return this.project(t, e)._subtract(i) }, _latLngBoundsToNewLayerBounds: function (t, e, i) { i = this._getNewPixelOrigin(i, e); return B([this.project(t.getSouthWest(), e)._subtract(i), this.project(t.getNorthWest(), e)._subtract(i), this.project(t.getSouthEast(), e)._subtract(i), this.project(t.getNorthEast(), e)._subtract(i)]) }, _getCenterLayerPoint: function () { return this.containerPointToLayerPoint(this.getSize()._divideBy(2)) }, _getCenterOffset: function (t) { return this.latLngToLayerPoint(t).subtract(this._getCenterLayerPoint()) }, _limitCenter: function (t, e, i) { if (!i) return t; var n = this.project(t, e), o = this.getSize().divideBy(2), o = new I(n.subtract(o), n.add(o)), i = this._getBoundsOffset(o, i, e); return Math.abs(i.x) <= 1 && Math.abs(i.y) <= 1 ? t : this.unproject(n.add(i), e) }, _limitOffset: function (t, e) { if (!e) return t; var i = this.getPixelBounds(), i = new I(i.min.add(t), i.max.add(t)); return t.add(this._getBoundsOffset(i, e)) }, _getBoundsOffset: function (t, e, i) { e = B(this.project(e.getNorthEast(), i), this.project(e.getSouthWest(), i)), i = e.min.subtract(t.min), t = e.max.subtract(t.max); return new Z(this._rebound(i.x, -t.x), this._rebound(i.y, -t.y)) }, _rebound: function (t, e) { return 0 < t + e ? Math.round(t - e) / 2 : Math.max(0, Math.ceil(t)) - Math.max(0, Math.floor(e)) }, _limitZoom: function (t) { var e = this.getMinZoom(), i = this.getMaxZoom(), n = Ct.any3d ? this.options.zoomSnap : 1; return n && (t = Math.round(t / n) * n), Math.max(e, Math.min(i, t)) }, _onPanTransitionStep: function () { this.fire("move") }, _onPanTransitionEnd: function () { le(this._mapPane, "leaflet-pan-anim"), this.fire("moveend") }, _tryAnimatedPan: function (t, e) { t = this._getCenterOffset(t)._trunc(); return !(!0 !== (e && e.animate) && !this.getSize().contains(t)) && (this.panBy(t, e), !0) }, _createAnimProxy: function () { var t = this._proxy = ie("div", "leaflet-proxy leaflet-zoom-animated"); this._panes.mapPane.appendChild(t), this.on("zoomanim", function (t) { var e = Jt, i = this._proxy.style[e]; pe(this._proxy, this.project(t.center, t.zoom), this.getZoomScale(t.zoom, 1)), i === this._proxy.style[e] && this._animatingZoom && this._onZoomTransitionEnd() }, this), this.on("load moveend", this._animMoveEnd, this), this._on("unload", this._destroyAnimProxy, this) }, _destroyAnimProxy: function () { ne(this._proxy), this.off("load moveend", this._animMoveEnd, this), delete this._proxy }, _animMoveEnd: function () { var t = this.getCenter(), e = this.getZoom(); pe(this._proxy, this.project(t, e), this.getZoomScale(e, 1)) }, _catchTransitionEnd: function (t) { this._animatingZoom && 0 <= t.propertyName.indexOf("transform") && this._onZoomTransitionEnd() }, _nothingToAnimate: function () { return !this._container.getElementsByClassName("leaflet-zoom-animated").length }, _tryAnimatedZoom: function (t, e, i) { if (this._animatingZoom) return !0; if (i = i || {}, !this._zoomAnimated || !1 === i.animate || this._nothingToAnimate() || Math.abs(e - this._zoom) > this.options.zoomAnimationThreshold) return !1; var n = this.getZoomScale(e), n = this._getCenterOffset(t)._divideBy(1 - 1 / n); return !(!0 !== i.animate && !this.getSize().contains(n)) && (z(function () { this._moveStart(!0, i.noMoveStart || !1)._animateZoom(t, e, !0) }, this), !0) }, _animateZoom: function (t, e, i, n) { this._mapPane && (i && (this._animatingZoom = !0, this._animateToCenter = t, this._animateToZoom = e, he(this._mapPane, "leaflet-zoom-anim")), this.fire("zoomanim", { center: t, zoom: e, noUpdate: n }), this._tempFireZoomEvent || (this._tempFireZoomEvent = this._zoom !== this._animateToZoom), this._move(this._animateToCenter, this._animateToZoom, void 0, !0), setTimeout(a(this._onZoomTransitionEnd, this), 250)) }, _onZoomTransitionEnd: function () { this._animatingZoom && (this._mapPane && le(this._mapPane, "leaflet-zoom-anim"), this._animatingZoom = !1, this._move(this._animateToCenter, this._animateToZoom, void 0, !0), this._tempFireZoomEvent && this.fire("zoom"), delete this._tempFireZoomEvent, this.fire("move"), this._moveEnd(!0)) } }); var We = C.extend({ options: { position: "topright" }, initialize: function (t) { _(this, t) }, getPosition: function () { return this.options.position }, setPosition: function (t) { var e = this._map; return e && e.removeControl(this), this.options.position = t, e && e.addControl(this), this }, getContainer: function () { return this._container }, addTo: function (t) { this.remove(), this._map = t; var e = this._container = this.onAdd(t), i = this.getPosition(), t = t._controlCorners[i]; return he(e, "leaflet-control"), -1 !== i.indexOf("bottom") ? t.insertBefore(e, t.firstChild) : t.appendChild(e), this._map.on("unload", this.remove, this), this }, remove: function () { return this._map && (ne(this._container), this.onRemove && this.onRemove(this._map), this._map.off("unload", this.remove, this), this._map = null), this }, _refocusOnMap: function (t) { this._map && t && 0 < t.screenX && 0 < t.screenY && this._map.getContainer().focus() } }), xt = function (t) { return new We(t) }; je.include({ addControl: function (t) { return t.addTo(this), this }, removeControl: function (t) { return t.remove(), this }, _initControlPos: function () { var i = this._controlCorners = {}, n = "leaflet-", o = this._controlContainer = ie("div", n + "control-container", this._container); function t(t, e) { i[t + e] = ie("div", n + t + " " + n + e, o) } t("top", "left"), t("top", "right"), t("bottom", "left"), t("bottom", "right") }, _clearControlPos: function () { for (var t in this._controlCorners) ne(this._controlCorners[t]); ne(this._controlContainer), delete this._controlCorners, delete this._controlContainer } }); var He = We.extend({ options: { collapsed: !0, position: "topright", autoZIndex: !0, hideSingleBase: !1, sortLayers: !1, sortFunction: function (t, e, i, n) { return i < n ? -1 : n < i ? 1 : 0 } }, initialize: function (t, e, i) { for (var n in _(this, i), this._layerControlInputs = [], this._layers = [], this._lastZIndex = 0, this._handlingClick = !1, this._preventClick = !1, t) this._addLayer(t[n], n); for (n in e) this._addLayer(e[n], n, !0) }, onAdd: function (t) { this._initLayout(), this._update(), (this._map = t).on("zoomend", this._checkDisabledLayers, this); for (var e = 0; e < this._layers.length; e++)this._layers[e].layer.on("add remove", this._onLayerChange, this); return this._container }, addTo: function (t) { return We.prototype.addTo.call(this, t), this._expandIfNotCollapsed() }, onRemove: function () { this._map.off("zoomend", this._checkDisabledLayers, this); for (var t = 0; t < this._layers.length; t++)this._layers[t].layer.off("add remove", this._onLayerChange, this) }, addBaseLayer: function (t, e) { return this._addLayer(t, e), this._map ? this._update() : this }, addOverlay: function (t, e) { return this._addLayer(t, e, !0), this._map ? this._update() : this }, removeLayer: function (t) { t.off("add remove", this._onLayerChange, this); t = this._getLayer(h(t)); return t && this._layers.splice(this._layers.indexOf(t), 1), this._map ? this._update() : this }, expand: function () { he(this._container, "leaflet-control-layers-expanded"), this._section.style.height = null; var t = this._map.getSize().y - (this._container.offsetTop + 50); return t < this._section.clientHeight ? (he(this._section, "leaflet-control-layers-scrollbar"), this._section.style.height = t + "px") : le(this._section, "leaflet-control-layers-scrollbar"), this._checkDisabledLayers(), this }, collapse: function () { return le(this._container, "leaflet-control-layers-expanded"), this }, _initLayout: function () { var t = "leaflet-control-layers", e = this._container = ie("div", t), i = this.options.collapsed; e.setAttribute("aria-haspopup", !0), Ze(e), ke(e); var n = this._section = ie("section", t + "-list"); i && (this._map.on("click", this.collapse, this), Le(e, { mouseenter: this._expandSafely, mouseleave: this.collapse }, this)); var o = this._layersLink = ie("a", t + "-toggle", e); o.href = "#", o.title = "Layers", o.setAttribute("role", "button"), Le(o, { keydown: function (t) { 13 === t.keyCode && this._expandSafely() }, click: function (t) { Ae(t), this._expandSafely() } }, this), i || this.expand(), this._baseLayersList = ie("div", t + "-base", n), this._separator = ie("div", t + "-separator", n), this._overlaysList = ie("div", t + "-overlays", n), e.appendChild(n) }, _getLayer: function (t) { for (var e = 0; e < this._layers.length; e++)if (this._layers[e] && h(this._layers[e].layer) === t) return this._layers[e] }, _addLayer: function (t, e, i) { this._map && t.on("add remove", this._onLayerChange, this), this._layers.push({ layer: t, name: e, overlay: i }), this.options.sortLayers && this._layers.sort(a(function (t, e) { return this.options.sortFunction(t.layer, e.layer, t.name, e.name) }, this)), this.options.autoZIndex && t.setZIndex && (this._lastZIndex++, t.setZIndex(this._lastZIndex)), this._expandIfNotCollapsed() }, _update: function () { if (!this._container) return this; oe(this._baseLayersList), oe(this._overlaysList), this._layerControlInputs = []; for (var t, e, i, n = 0, o = 0; o < this._layers.length; o++)i = this._layers[o], this._addItem(i), e = e || i.overlay, t = t || !i.overlay, n += i.overlay ? 0 : 1; return this.options.hideSingleBase && (this._baseLayersList.style.display = (t = t && 1 < n) ? "" : "none"), this._separator.style.display = e && t ? "" : "none", this }, _onLayerChange: function (t) { this._handlingClick || this._update(); var e = this._getLayer(h(t.target)), t = e.overlay ? "add" === t.type ? "overlayadd" : "overlayremove" : "add" === t.type ? "baselayerchange" : null; t && this._map.fire(t, e) }, _createRadioElement: function (t, e) { t = '<input type="radio" class="leaflet-control-layers-selector" name="' + t + '"' + (e ? ' checked="checked"' : "") + "/>", e = document.createElement("div"); return e.innerHTML = t, e.firstChild }, _addItem: function (t) { var e, i = document.createElement("label"), n = this._map.hasLayer(t.layer); t.overlay ? ((e = document.createElement("input")).type = "checkbox", e.className = "leaflet-control-layers-selector", e.defaultChecked = n) : e = this._createRadioElement("leaflet-base-layers_" + h(this), n), this._layerControlInputs.push(e), e.layerId = h(t.layer), Le(e, "click", this._onInputClick, this); var o = document.createElement("span"); o.innerHTML = " " + t.name; n = document.createElement("span"); return i.appendChild(n), n.appendChild(e), n.appendChild(o), (t.overlay ? this._overlaysList : this._baseLayersList).appendChild(i), this._checkDisabledLayers(), i }, _onInputClick: function () { if (!this._preventClick) { var t, e, i = this._layerControlInputs, n = [], o = []; this._handlingClick = !0; for (var s = i.length - 1; 0 <= s; s--)t = i[s], e = this._getLayer(t.layerId).layer, t.checked ? n.push(e) : t.checked || o.push(e); for (s = 0; s < o.length; s++)this._map.hasLayer(o[s]) && this._map.removeLayer(o[s]); for (s = 0; s < n.length; s++)this._map.hasLayer(n[s]) || this._map.addLayer(n[s]); this._handlingClick = !1, this._refocusOnMap() } }, _checkDisabledLayers: function () { for (var t, e, i = this._layerControlInputs, n = this._map.getZoom(), o = i.length - 1; 0 <= o; o--)t = i[o], e = this._getLayer(t.layerId).layer, t.disabled = void 0 !== e.options.minZoom && n < e.options.minZoom || void 0 !== e.options.maxZoom && n > e.options.maxZoom }, _expandIfNotCollapsed: function () { return this._map && !this.options.collapsed && this.expand(), this }, _expandSafely: function () { var t = this._section; this._preventClick = !0, Le(t, "click", Ae), this.expand(); var e = this; setTimeout(function () { Te(t, "click", Ae), e._preventClick = !1 }) } }), Ue = We.extend({ options: { position: "topleft", zoomInText: '<span aria-hidden="true">+</span>', zoomInTitle: "Zoom in", zoomOutText: '<span aria-hidden="true">&#x2212;</span>', zoomOutTitle: "Zoom out" }, onAdd: function (t) { var e = "leaflet-control-zoom", i = ie("div", e + " leaflet-bar"), n = this.options; return this._zoomInButton = this._createButton(n.zoomInText, n.zoomInTitle, e + "-in", i, this._zoomIn), this._zoomOutButton = this._createButton(n.zoomOutText, n.zoomOutTitle, e + "-out", i, this._zoomOut), this._updateDisabled(), t.on("zoomend zoomlevelschange", this._updateDisabled, this), i }, onRemove: function (t) { t.off("zoomend zoomlevelschange", this._updateDisabled, this) }, disable: function () { return this._disabled = !0, this._updateDisabled(), this }, enable: function () { return this._disabled = !1, this._updateDisabled(), this }, _zoomIn: function (t) { !this._disabled && this._map._zoom < this._map.getMaxZoom() && this._map.zoomIn(this._map.options.zoomDelta * (t.shiftKey ? 3 : 1)) }, _zoomOut: function (t) { !this._disabled && this._map._zoom > this._map.getMinZoom() && this._map.zoomOut(this._map.options.zoomDelta * (t.shiftKey ? 3 : 1)) }, _createButton: function (t, e, i, n, o) { n = ie("a", i, n); return n.innerHTML = t, n.href = "#", n.title = e, n.setAttribute("role", "button"), n.setAttribute("aria-label", e), Ze(n), Le(n, "click", Oe), Le(n, "click", o, this), Le(n, "click", this._refocusOnMap, this), n }, _updateDisabled: function () { var t = this._map, e = "leaflet-disabled"; le(this._zoomInButton, e), le(this._zoomOutButton, e), this._zoomInButton.setAttribute("aria-disabled", "false"), this._zoomOutButton.setAttribute("aria-disabled", "false"), !this._disabled && t._zoom !== t.getMinZoom() || (he(this._zoomOutButton, e), this._zoomOutButton.setAttribute("aria-disabled", "true")), !this._disabled && t._zoom !== t.getMaxZoom() || (he(this._zoomInButton, e), this._zoomInButton.setAttribute("aria-disabled", "true")) } }); je.mergeOptions({ zoomControl: !0 }), je.addInitHook(function () { this.options.zoomControl && (this.zoomControl = new Ue, this.addControl(this.zoomControl)) }); var Ve = We.extend({ options: { position: "bottomleft", maxWidth: 100, metric: !0, imperial: !0 }, onAdd: function (t) { var e = "leaflet-control-scale", i = ie("div", e), n = this.options; return this._addScales(n, e + "-line", i), t.on(n.updateWhenIdle ? "moveend" : "move", this._update, this), t.whenReady(this._update, this), i }, onRemove: function (t) { t.off(this.options.updateWhenIdle ? "moveend" : "move", this._update, this) }, _addScales: function (t, e, i) { t.metric && (this._mScale = ie("div", e, i)), t.imperial && (this._iScale = ie("div", e, i)) }, _update: function () { var t = this._map, e = t.getSize().y / 2, e = t.distance(t.containerPointToLatLng([0, e]), t.containerPointToLatLng([this.options.maxWidth, e])); this._updateScales(e) }, _updateScales: function (t) { this.options.metric && t && this._updateMetric(t), this.options.imperial && t && this._updateImperial(t) }, _updateMetric: function (t) { var e = this._getRoundNum(t); this._updateScale(this._mScale, e < 1e3 ? e + " m" : e / 1e3 + " km", e / t) }, _updateImperial: function (t) { var e, i = 3.2808399 * t; 5280 < i ? (t = this._getRoundNum(e = i / 5280), this._updateScale(this._iScale, t + " mi", t / e)) : (e = this._getRoundNum(i), this._updateScale(this._iScale, e + " ft", e / i)) }, _updateScale: function (t, e, i) { t.style.width = Math.round(this.options.maxWidth * i) + "px", t.innerHTML = e }, _getRoundNum: function (t) { var e = Math.pow(10, (Math.floor(t) + "").length - 1), t = t / e; return e * (t = 10 <= t ? 10 : 5 <= t ? 5 : 3 <= t ? 3 : 2 <= t ? 2 : 1) } }), qe = We.extend({ options: { position: "bottomright", prefix: '<a href="https://leafletjs.com" title="A JavaScript library for interactive maps">' + (Ct.inlineSvg ? '<svg aria-hidden="true" xmlns="http://www.w3.org/2000/svg" width="12" height="8" viewBox="0 0 12 8" class="leaflet-attribution-flag"><path fill="#4C7BE1" d="M0 0h12v4H0z"/><path fill="#FFD500" d="M0 4h12v3H0z"/><path fill="#E0BC00" d="M0 7h12v1H0z"/></svg> ' : "") + "Leaflet</a>" }, initialize: function (t) { _(this, t), this._attributions = {} }, onAdd: function (t) { for (var e in (t.attributionControl = this)._container = ie("div", "leaflet-control-attribution"), Ze(this._container), t._layers) t._layers[e].getAttribution && this.addAttribution(t._layers[e].getAttribution()); return this._update(), t.on("layeradd", this._addAttribution, this), this._container }, onRemove: function (t) { t.off("layeradd", this._addAttribution, this) }, _addAttribution: function (t) { t.layer.getAttribution && (this.addAttribution(t.layer.getAttribution()), t.layer.once("remove", function () { this.removeAttribution(t.layer.getAttribution()) }, this)) }, setPrefix: function (t) { return this.options.prefix = t, this._update(), this }, addAttribution: function (t) { return t && (this._attributions[t] || (this._attributions[t] = 0), this._attributions[t]++, this._update()), this }, removeAttribution: function (t) { return t && this._attributions[t] && (this._attributions[t]--, this._update()), this }, _update: function () { if (this._map) { var t, e = []; for (t in this._attributions) this._attributions[t] && e.push(t); var i = []; this.options.prefix && i.push(this.options.prefix), e.length && i.push(e.join(", ")), this._container.innerHTML = i.join(' <span aria-hidden="true">|</span> ') } } }); je.mergeOptions({ attributionControl: !0 }), je.addInitHook(function () { this.options.attributionControl && (new qe).addTo(this) }); We.Layers = He, We.Zoom = Ue, We.Scale = Ve, We.Attribution = qe, xt.layers = function (t, e, i) { return new He(t, e, i) }, xt.zoom = function (t) { return new Ue(t) }, xt.scale = function (t) { return new Ve(t) }, xt.attribution = function (t) { return new qe(t) }; wt = C.extend({ initialize: function (t) { this._map = t }, enable: function () { return this._enabled || (this._enabled = !0, this.addHooks()), this }, disable: function () { return this._enabled && (this._enabled = !1, this.removeHooks()), this }, enabled: function () { return !!this._enabled } }); wt.addTo = function (t, e) { return t.addHandler(e, this), this }; var Lt = { Events: E }, Ge = Ct.touch ? "touchstart mousedown" : "mousedown", Ke = k.extend({ options: { clickTolerance: 3 }, initialize: function (t, e, i, n) { _(this, n), this._element = t, this._dragStartTarget = e || t, this._preventOutline = i }, enable: function () { this._enabled || (Le(this._dragStartTarget, Ge, this._onDown, this), this._enabled = !0) }, disable: function () { this._enabled && (Ke._dragging === this && this.finishDrag(!0), Te(this._dragStartTarget, Ge, this._onDown, this), this._enabled = !1, this._moved = !1) }, _onDown: function (t) { var e, i; this._enabled && (this._moved = !1, ae(this._element, "leaflet-zoom-anim") || (t.touches && 1 !== t.touches.length ? Ke._dragging === this && this.finishDrag() : Ke._dragging || t.shiftKey || 1 !== t.which && 1 !== t.button && !t.touches || ((Ke._dragging = this)._preventOutline && ye(this._element), ge(), Gt(), this._moving || (this.fire("down"), e = t.touches ? t.touches[0] : t, i = we(this._element), this._startPoint = new Z(e.clientX, e.clientY), this._startPos = fe(this._element), this._parentScale = be(i), t = "mousedown" === t.type, Le(document, t ? "mousemove" : "touchmove", this._onMove, this), Le(document, t ? "mouseup" : "touchend touchcancel", this._onUp, this))))) }, _onMove: function (t) { var e; this._enabled && (t.touches && 1 < t.touches.length ? this._moved = !0 : ((e = new Z((e = t.touches && 1 === t.touches.length ? t.touches[0] : t).clientX, e.clientY)._subtract(this._startPoint)).x || e.y) && (Math.abs(e.x) + Math.abs(e.y) < this.options.clickTolerance || (e.x /= this._parentScale.x, e.y /= this._parentScale.y, Ae(t), this._moved || (this.fire("dragstart"), this._moved = !0, he(document.body, "leaflet-dragging"), this._lastTarget = t.target || t.srcElement, window.SVGElementInstance && this._lastTarget instanceof window.SVGElementInstance && (this._lastTarget = this._lastTarget.correspondingUseElement), he(this._lastTarget, "leaflet-drag-target")), this._newPos = this._startPos.add(e), this._moving = !0, this._lastEvent = t, this._updatePosition()))) }, _updatePosition: function () { var t = { originalEvent: this._lastEvent }; this.fire("predrag", t), me(this._element, this._newPos), this.fire("drag", t) }, _onUp: function () { this._enabled && this.finishDrag() }, finishDrag: function (t) { le(document.body, "leaflet-dragging"), this._lastTarget && (le(this._lastTarget, "leaflet-drag-target"), this._lastTarget = null), Te(document, "mousemove touchmove", this._onMove, this), Te(document, "mouseup touchend touchcancel", this._onUp, this), ve(), Kt(); var e = this._moved && this._moving; this._moving = !1, Ke._dragging = !1, e && this.fire("dragend", { noInertia: t, distance: this._newPos.distanceTo(this._startPos) }) } }); function Ye(t, e, i) { for (var n, o, s, r, a, h, l, c = [1, 4, 2, 8], u = 0, d = t.length; u < d; u++)t[u]._code = ni(t[u], e); for (s = 0; s < 4; s++){ for (h = c[s], n = [], u = 0, o = (d = t.length) - 1; u < d; o = u++)r = t[u], a = t[o], r._code & h ? a._code & h || ((l = ii(a, r, h, e, i))._code = ni(l, e), n.push(l)) : (a._code & h && ((l = ii(a, r, h, e, i))._code = ni(l, e), n.push(l)), n.push(r)); t = n } return t } function Xe(t, e) { var i, n, o, s, r, a, h; if (!t || 0 === t.length) throw new Error("latlngs not passed"); si(t) || (console.warn("latlngs are not flat! Only the first ring will be used"), t = t[0]); var l = F([0, 0]), c = D(t); c.getNorthWest().distanceTo(c.getSouthWest()) * c.getNorthEast().distanceTo(c.getNorthWest()) < 1700 && (l = Je(t)); for (var u = t.length, d = [], _ = 0; _ < u; _++){ var p = F(t[_]); d.push(e.project(F([p.lat - l.lat, p.lng - l.lng]))) } for (_ = r = a = h = 0, i = u - 1; _ < u; i = _++)n = d[_], o = d[i], s = n.y * o.x - o.y * n.x, a += (n.x + o.x) * s, h += (n.y + o.y) * s, r += 3 * s; c = 0 === r ? d[0] : [a / r, h / r], c = e.unproject(O(c)); return F([c.lat + l.lat, c.lng + l.lng]) } function Je(t) { for (var e = 0, i = 0, n = 0, o = 0; o < t.length; o++){ var s = F(t[o]); e += s.lat, i += s.lng, n++ } return F([e / n, i / n]) } var $e, bt = { __proto__: null, clipPolygon: Ye, polygonCenter: Xe, centroid: Je }; function Qe(t, e) { if (!e || !t.length) return t.slice(); e *= e; return t = function (t, e) { var i = t.length, n = new (typeof Uint8Array != void 0 + "" ? Uint8Array : Array)(i); n[0] = n[i - 1] = 1, function t(e, i, n, o, s) { var r, a, h, l = 0; for (a = o + 1; a <= s - 1; a++)h = oi(e[a], e[o], e[s], !0), l < h && (r = a, l = h); n < l && (i[r] = 1, t(e, i, n, o, r), t(e, i, n, r, s)) }(t, n, e, 0, i - 1); var o, s = []; for (o = 0; o < i; o++)n[o] && s.push(t[o]); return s }(t = function (t, e) { for (var i = [t[0]], n = 1, o = 0, s = t.length; n < s; n++)(function (t, e) { var i = e.x - t.x, t = e.y - t.y; return i * i + t * t })(t[n], t[o]) > e && (i.push(t[n]), o = n); o < s - 1 && i.push(t[s - 1]); return i }(t, e), e) } function ti(t, e, i) { return Math.sqrt(oi(t, e, i, !0)) } function ei(t, e, i, n, o) { var s, r, a, h = n ? $e : ni(t, i), l = ni(e, i); for ($e = l; ;){ if (!(h | l)) return [t, e]; if (h & l) return !1; a = ni(r = ii(t, e, s = h || l, i, o), i), s === h ? (t = r, h = a) : (e = r, l = a) } } function ii(t, e, i, n, o) { var s, r, a = e.x - t.x, h = e.y - t.y, e = n.min, n = n.max; return 8 & i ? (s = t.x + a * (n.y - t.y) / h, r = n.y) : 4 & i ? (s = t.x + a * (e.y - t.y) / h, r = e.y) : 2 & i ? (s = n.x, r = t.y + h * (n.x - t.x) / a) : 1 & i && (s = e.x, r = t.y + h * (e.x - t.x) / a), new Z(s, r, o) } function ni(t, e) { var i = 0; return t.x < e.min.x ? i |= 1 : t.x > e.max.x && (i |= 2), t.y < e.min.y ? i |= 4 : t.y > e.max.y && (i |= 8), i } function oi(t, e, i, n) { var o = e.x, s = e.y, r = i.x - o, a = i.y - s, e = r * r + a * a; return 0 < e && (1 < (e = ((t.x - o) * r + (t.y - s) * a) / e) ? (o = i.x, s = i.y) : 0 < e && (o += r * e, s += a * e)), r = t.x - o, a = t.y - s, n ? r * r + a * a : new Z(o, s) } function si(t) { return !g(t[0]) || "object" != typeof t[0][0] && void 0 !== t[0][0] } function ri(t) { return console.warn("Deprecated use of _flat, please use L.LineUtil.isFlat instead."), si(t) } function ai(t, e) { var i, n, o, s, r, a; if (!t || 0 === t.length) throw new Error("latlngs not passed"); si(t) || (console.warn("latlngs are not flat! Only the first ring will be used"), t = t[0]); var h = F([0, 0]), l = D(t); l.getNorthWest().distanceTo(l.getSouthWest()) * l.getNorthEast().distanceTo(l.getNorthWest()) < 1700 && (h = Je(t)); for (var c = t.length, u = [], d = 0; d < c; d++){ var _ = F(t[d]); u.push(e.project(F([_.lat - h.lat, _.lng - h.lng]))) } for (i = d = 0; d < c - 1; d++)i += u[d].distanceTo(u[d + 1]) / 2; if (0 === i) a = u[0]; else for (n = d = 0; d < c - 1; d++)if (o = u[d], s = u[d + 1], i < (n += r = o.distanceTo(s))) { a = [s.x - (r = (n - i) / r) * (s.x - o.x), s.y - r * (s.y - o.y)]; break } l = e.unproject(O(a)); return F([l.lat + h.lat, l.lng + h.lng]) } var Pt = { __proto__: null, simplify: Qe, pointToSegmentDistance: ti, closestPointOnSegment: function (t, e, i) { return oi(t, e, i) }, clipSegment: ei, _getEdgeIntersection: ii, _getBitCode: ni, _sqClosestPointOnSegment: oi, isFlat: si, _flat: ri, polylineCenter: ai }, H = { project: function (t) { return new Z(t.lng, t.lat) }, unproject: function (t) { return new R(t.y, t.x) }, bounds: new I([-180, -90], [180, 90]) }, Tt = { R: 6378137, R_MINOR: 6356752.314245179, bounds: new I([-20037508.34279, -15496570.73972], [20037508.34279, 18764656.23138]), project: function (t) { var e = Math.PI / 180, i = this.R, n = t.lat * e, o = this.R_MINOR / i, s = Math.sqrt(1 - o * o), o = s * Math.sin(n), s = Math.tan(Math.PI / 4 - n / 2) / Math.pow((1 - o) / (1 + o), s / 2), n = -i * Math.log(Math.max(s, 1e-10)); return new Z(t.lng * e * i, n) }, unproject: function (t) { for (var e, i = 180 / Math.PI, n = this.R, o = this.R_MINOR / n, s = Math.sqrt(1 - o * o), r = Math.exp(-t.y / n), a = Math.PI / 2 - 2 * Math.atan(r), h = 0, l = .1; h < 15 && 1e-7 < Math.abs(l); h++)e = s * Math.sin(a), e = Math.pow((1 - e) / (1 + e), s / 2), a += l = Math.PI / 2 - 2 * Math.atan(r * e) - a; return new R(a * i, t.x * i / n) } }, zt = { __proto__: null, LonLat: H, Mercator: Tt, SphericalMercator: U }, J = l({}, W, { code: "EPSG:3395", projection: Tt, transformation: q(ot = .5 / (Math.PI * Tt.R), .5, -ot, .5) }), hi = l({}, W, { code: "EPSG:4326", projection: H, transformation: q(1 / 180, 1, -1 / 180, .5) }), St = l({}, j, { projection: H, transformation: q(1, 0, -1, 0), scale: function (t) { return Math.pow(2, t) }, zoom: function (t) { return Math.log(t) / Math.LN2 }, distance: function (t, e) { var i = e.lng - t.lng, t = e.lat - t.lat; return Math.sqrt(i * i + t * t) }, infinite: !0 }); j.Earth = W, j.EPSG3395 = J, j.EPSG3857 = G, j.EPSG900913 = K, j.EPSG4326 = hi, j.Simple = St; E = k.extend({ options: { pane: "overlayPane", attribution: null, bubblingMouseEvents: !0 }, addTo: function (t) { return t.addLayer(this), this }, remove: function () { return this.removeFrom(this._map || this._mapToAdd) }, removeFrom: function (t) { return t && t.removeLayer(this), this }, getPane: function (t) { return this._map.getPane(t ? this.options[t] || t : this.options.pane) }, addInteractiveTarget: function (t) { return this._map._targets[h(t)] = this }, removeInteractiveTarget: function (t) { return delete this._map._targets[h(t)], this }, getAttribution: function () { return this.options.attribution }, _layerAdd: function (t) { var e, i = t.target; i.hasLayer(this) && (this._map = i, this._zoomAnimated = i._zoomAnimated, this.getEvents && (e = this.getEvents(), i.on(e, this), this.once("remove", function () { i.off(e, this) }, this)), this.onAdd(i), this.fire("add"), i.fire("layeradd", { layer: this })) } }); je.include({ addLayer: function (t) { if (!t._layerAdd) throw new Error("The provided object is not a Layer."); var e = h(t); return this._layers[e] || ((this._layers[e] = t)._mapToAdd = this, t.beforeAdd && t.beforeAdd(this), this.whenReady(t._layerAdd, t)), this }, removeLayer: function (t) { var e = h(t); return this._layers[e] && (this._loaded && t.onRemove(this), delete this._layers[e], this._loaded && (this.fire("layerremove", { layer: t }), t.fire("remove")), t._map = t._mapToAdd = null), this }, hasLayer: function (t) { return h(t) in this._layers }, eachLayer: function (t, e) { for (var i in this._layers) t.call(e, this._layers[i]); return this }, _addLayers: function (t) { for (var e = 0, i = (t = t ? g(t) ? t : [t] : []).length; e < i; e++)this.addLayer(t[e]) }, _addZoomLimit: function (t) { isNaN(t.options.maxZoom) && isNaN(t.options.minZoom) || (this._zoomBoundLayers[h(t)] = t, this._updateZoomLevels()) }, _removeZoomLimit: function (t) { t = h(t); this._zoomBoundLayers[t] && (delete this._zoomBoundLayers[t], this._updateZoomLevels()) }, _updateZoomLevels: function () { var t, e = 1 / 0, i = -1 / 0, n = this._getZoomSpan(); for (t in this._zoomBoundLayers) var o = this._zoomBoundLayers[t].options, e = void 0 === o.minZoom ? e : Math.min(e, o.minZoom), i = void 0 === o.maxZoom ? i : Math.max(i, o.maxZoom); this._layersMaxZoom = i === -1 / 0 ? void 0 : i, this._layersMinZoom = e === 1 / 0 ? void 0 : e, n !== this._getZoomSpan() && this.fire("zoomlevelschange"), void 0 === this.options.maxZoom && this._layersMaxZoom && this.getZoom() > this._layersMaxZoom && this.setZoom(this._layersMaxZoom), void 0 === this.options.minZoom && this._layersMinZoom && this.getZoom() < this._layersMinZoom && this.setZoom(this._layersMinZoom) } }); var li = E.extend({ initialize: function (t, e) { var i, n; if (_(this, e), this._layers = {}, t) for (i = 0, n = t.length; i < n; i++)this.addLayer(t[i]) }, addLayer: function (t) { var e = this.getLayerId(t); return this._layers[e] = t, this._map && this._map.addLayer(t), this }, removeLayer: function (t) { t = t in this._layers ? t : this.getLayerId(t); return this._map && this._layers[t] && this._map.removeLayer(this._layers[t]), delete this._layers[t], this }, hasLayer: function (t) { return ("number" == typeof t ? t : this.getLayerId(t)) in this._layers }, clearLayers: function () { return this.eachLayer(this.removeLayer, this) }, invoke: function (t) { var e, i, n = Array.prototype.slice.call(arguments, 1); for (e in this._layers) (i = this._layers[e])[t] && i[t].apply(i, n); return this }, onAdd: function (t) { this.eachLayer(t.addLayer, t) }, onRemove: function (t) { this.eachLayer(t.removeLayer, t) }, eachLayer: function (t, e) { for (var i in this._layers) t.call(e, this._layers[i]); return this }, getLayer: function (t) { return this._layers[t] }, getLayers: function () { var t = []; return this.eachLayer(t.push, t), t }, setZIndex: function (t) { return this.invoke("setZIndex", t) }, getLayerId: h }), ci = li.extend({ addLayer: function (t) { return this.hasLayer(t) ? this : (t.addEventParent(this), li.prototype.addLayer.call(this, t), this.fire("layeradd", { layer: t })) }, removeLayer: function (t) { return this.hasLayer(t) ? ((t = t in this._layers ? this._layers[t] : t).removeEventParent(this), li.prototype.removeLayer.call(this, t), this.fire("layerremove", { layer: t })) : this }, setStyle: function (t) { return this.invoke("setStyle", t) }, bringToFront: function () { return this.invoke("bringToFront") }, bringToBack: function () { return this.invoke("bringToBack") }, getBounds: function () { var t, e = new N; for (t in this._layers) { var i = this._layers[t]; e.extend(i.getBounds ? i.getBounds() : i.getLatLng()) } return e } }), ui = C.extend({ options: { popupAnchor: [0, 0], tooltipAnchor: [0, 0], crossOrigin: !1 }, initialize: function (t) { _(this, t) }, createIcon: function (t) { return this._createIcon("icon", t) }, createShadow: function (t) { return this._createIcon("shadow", t) }, _createIcon: function (t, e) { var i = this._getIconUrl(t); if (!i) { if ("icon" === t) throw new Error("iconUrl not set in Icon options (see the docs)."); return null } e = this._createImg(i, e && "IMG" === e.tagName ? e : null); return this._setIconStyles(e, t), !this.options.crossOrigin && "" !== this.options.crossOrigin || (e.crossOrigin = !0 === this.options.crossOrigin ? "" : this.options.crossOrigin), e }, _setIconStyles: function (t, e) { var i = this.options, n = i[e + "Size"], o = O(n = "number" == typeof n ? [n, n] : n), n = O("shadow" === e && i.shadowAnchor || i.iconAnchor || o && o.divideBy(2, !0)); t.className = "leaflet-marker-" + e + " " + (i.className || ""), n && (t.style.marginLeft = -n.x + "px", t.style.marginTop = -n.y + "px"), o && (t.style.width = o.x + "px", t.style.height = o.y + "px") }, _createImg: function (t, e) { return (e = e || document.createElement("img")).src = t, e }, _getIconUrl: function (t) { return Ct.retina && this.options[t + "RetinaUrl"] || this.options[t + "Url"] } }); var di = ui.extend({ options: { iconUrl: "marker-icon.png", iconRetinaUrl: "marker-icon-2x.png", shadowUrl: "marker-shadow.png", iconSize: [25, 41], iconAnchor: [12, 41], popupAnchor: [1, -34], tooltipAnchor: [16, -28], shadowSize: [41, 41] }, _getIconUrl: function (t) { return "string" != typeof di.imagePath && (di.imagePath = this._detectIconPath()), (this.options.imagePath || di.imagePath) + ui.prototype._getIconUrl.call(this, t) }, _stripUrl: function (t) { function e(t, e, i) { return (t = e.exec(t)) && t[i] } return (t = e(t, /^url\((['"])?(.+)\1\)$/, 2)) && e(t, /^(.*)marker-icon\.png$/, 1) }, _detectIconPath: function () { var t = ie("div", "leaflet-default-icon-path", document.body), e = ee(t, "background-image") || ee(t, "backgroundImage"); if (document.body.removeChild(t), e = this._stripUrl(e)) return e; e = document.querySelector('link[href$="leaflet.css"]'); return e ? e.href.substring(0, e.href.length - "leaflet.css".length - 1) : "" } }), _i = wt.extend({ initialize: function (t) { this._marker = t }, addHooks: function () { var t = this._marker._icon; this._draggable || (this._draggable = new Ke(t, t, !0)), this._draggable.on({ dragstart: this._onDragStart, predrag: this._onPreDrag, drag: this._onDrag, dragend: this._onDragEnd }, this).enable(), he(t, "leaflet-marker-draggable") }, removeHooks: function () { this._draggable.off({ dragstart: this._onDragStart, predrag: this._onPreDrag, drag: this._onDrag, dragend: this._onDragEnd }, this).disable(), this._marker._icon && le(this._marker._icon, "leaflet-marker-draggable") }, moved: function () { return this._draggable && this._draggable._moved }, _adjustPan: function (t) { var e = this._marker, i = e._map, n = this._marker.options.autoPanSpeed, o = this._marker.options.autoPanPadding, s = fe(e._icon), r = i.getPixelBounds(), a = i.getPixelOrigin(), o = B(r.min._subtract(a).add(o), r.max._subtract(a).subtract(o)); o.contains(s) || (n = O((Math.max(o.max.x, s.x) - o.max.x) / (r.max.x - o.max.x) - (Math.min(o.min.x, s.x) - o.min.x) / (r.min.x - o.min.x), (Math.max(o.max.y, s.y) - o.max.y) / (r.max.y - o.max.y) - (Math.min(o.min.y, s.y) - o.min.y) / (r.min.y - o.min.y)).multiplyBy(n), i.panBy(n, { animate: !1 }), this._draggable._newPos._add(n), this._draggable._startPos._add(n), me(e._icon, this._draggable._newPos), this._onDrag(t), this._panRequest = z(this._adjustPan.bind(this, t))) }, _onDragStart: function () { this._oldLatLng = this._marker.getLatLng(), this._marker.closePopup && this._marker.closePopup(), this._marker.fire("movestart").fire("dragstart") }, _onPreDrag: function (t) { this._marker.options.autoPan && (S(this._panRequest), this._panRequest = z(this._adjustPan.bind(this, t))) }, _onDrag: function (t) { var e = this._marker, i = e._shadow, n = fe(e._icon), o = e._map.layerPointToLatLng(n); i && me(i, n), e._latlng = o, t.latlng = o, t.oldLatLng = this._oldLatLng, e.fire("move", t).fire("drag", t) }, _onDragEnd: function (t) { S(this._panRequest), delete this._oldLatLng, this._marker.fire("moveend").fire("dragend", t) } }), pi = E.extend({ options: { icon: new di, interactive: !0, keyboard: !0, title: "", alt: "Marker", zIndexOffset: 0, opacity: 1, riseOnHover: !1, riseOffset: 250, pane: "markerPane", shadowPane: "shadowPane", bubblingMouseEvents: !1, autoPanOnFocus: !0, draggable: !1, autoPan: !1, autoPanPadding: [50, 50], autoPanSpeed: 10 }, initialize: function (t, e) { _(this, e), this._latlng = F(t) }, onAdd: function (t) { this._zoomAnimated = this._zoomAnimated && t.options.markerZoomAnimation, this._zoomAnimated && t.on("zoomanim", this._animateZoom, this), this._initIcon(), this.update() }, onRemove: function (t) { this.dragging && this.dragging.enabled() && (this.options.draggable = !0, this.dragging.removeHooks()), delete this.dragging, this._zoomAnimated && t.off("zoomanim", this._animateZoom, this), this._removeIcon(), this._removeShadow() }, getEvents: function () { return { zoom: this.update, viewreset: this.update } }, getLatLng: function () { return this._latlng }, setLatLng: function (t) { var e = this._latlng; return this._latlng = F(t), this.update(), this.fire("move", { oldLatLng: e, latlng: this._latlng }) }, setZIndexOffset: function (t) { return this.options.zIndexOffset = t, this.update() }, getIcon: function () { return this.options.icon }, setIcon: function (t) { return this.options.icon = t, this._map && (this._initIcon(), this.update()), this._popup && this.bindPopup(this._popup, this._popup.options), this }, getElement: function () { return this._icon }, update: function () { var t; return this._icon && this._map && (t = this._map.latLngToLayerPoint(this._latlng).round(), this._setPos(t)), this }, _initIcon: function () { var t = this.options, e = "leaflet-zoom-" + (this._zoomAnimated ? "animated" : "hide"), i = t.icon.createIcon(this._icon), n = !1; i !== this._icon && (this._icon && this._removeIcon(), n = !0, t.title && (i.title = t.title), "IMG" === i.tagName && (i.alt = t.alt || "")), he(i, e), t.keyboard && (i.tabIndex = "0", i.setAttribute("role", "button")), this._icon = i, t.riseOnHover && this.on({ mouseover: this._bringToFront, mouseout: this._resetZIndex }), this.options.autoPanOnFocus && Le(i, "focus", this._panOnFocus, this); var o = t.icon.createShadow(this._shadow), i = !1; o !== this._shadow && (this._removeShadow(), i = !0), o && (he(o, e), o.alt = ""), this._shadow = o, t.opacity < 1 && this._updateOpacity(), n && this.getPane().appendChild(this._icon), this._initInteraction(), o && i && this.getPane(t.shadowPane).appendChild(this._shadow) }, _removeIcon: function () { this.options.riseOnHover && this.off({ mouseover: this._bringToFront, mouseout: this._resetZIndex }), this.options.autoPanOnFocus && Te(this._icon, "focus", this._panOnFocus, this), ne(this._icon), this.removeInteractiveTarget(this._icon), this._icon = null }, _removeShadow: function () { this._shadow && ne(this._shadow), this._shadow = null }, _setPos: function (t) { this._icon && me(this._icon, t), this._shadow && me(this._shadow, t), this._zIndex = t.y + this.options.zIndexOffset, this._resetZIndex() }, _updateZIndex: function (t) { this._icon && (this._icon.style.zIndex = this._zIndex + t) }, _animateZoom: function (t) { t = this._map._latLngToNewLayerPoint(this._latlng, t.zoom, t.center).round(); this._setPos(t) }, _initInteraction: function () { var t; this.options.interactive && (he(this._icon, "leaflet-interactive"), this.addInteractiveTarget(this._icon), _i && (t = this.options.draggable, this.dragging && (t = this.dragging.enabled(), this.dragging.disable()), this.dragging = new _i(this), t && this.dragging.enable())) }, setOpacity: function (t) { return this.options.opacity = t, this._map && this._updateOpacity(), this }, _updateOpacity: function () { var t = this.options.opacity; this._icon && de(this._icon, t), this._shadow && de(this._shadow, t) }, _bringToFront: function () { this._updateZIndex(this.options.riseOffset) }, _resetZIndex: function () { this._updateZIndex(0) }, _panOnFocus: function () { var t, e, i = this._map; i && (t = (e = this.options.icon.options).iconSize ? O(e.iconSize) : O(0, 0), e = e.iconAnchor ? O(e.iconAnchor) : O(0, 0), i.panInside(this._latlng, { paddingTopLeft: e, paddingBottomRight: t.subtract(e) })) }, _getPopupAnchor: function () { return this.options.icon.options.popupAnchor }, _getTooltipAnchor: function () { return this.options.icon.options.tooltipAnchor } }); var mi = E.extend({ options: { stroke: !0, color: "#3388ff", weight: 3, opacity: 1, lineCap: "round", lineJoin: "round", dashArray: null, dashOffset: null, fill: !1, fillColor: null, fillOpacity: .2, fillRule: "evenodd", interactive: !0, bubblingMouseEvents: !0 }, beforeAdd: function (t) { this._renderer = t.getRenderer(this) }, onAdd: function () { this._renderer._initPath(this), this._reset(), this._renderer._addPath(this) }, onRemove: function () { this._renderer._removePath(this) }, redraw: function () { return this._map && this._renderer._updatePath(this), this }, setStyle: function (t) { return _(this, t), this._renderer && (this._renderer._updateStyle(this), this.options.stroke && t && Object.prototype.hasOwnProperty.call(t, "weight") && this._updateBounds()), this }, bringToFront: function () { return this._renderer && this._renderer._bringToFront(this), this }, bringToBack: function () { return this._renderer && this._renderer._bringToBack(this), this }, getElement: function () { return this._path }, _reset: function () { this._project(), this._update() }, _clickTolerance: function () { return (this.options.stroke ? this.options.weight / 2 : 0) + (this._renderer.options.tolerance || 0) } }), fi = mi.extend({ options: { fill: !0, radius: 10 }, initialize: function (t, e) { _(this, e), this._latlng = F(t), this._radius = this.options.radius }, setLatLng: function (t) { var e = this._latlng; return this._latlng = F(t), this.redraw(), this.fire("move", { oldLatLng: e, latlng: this._latlng }) }, getLatLng: function () { return this._latlng }, setRadius: function (t) { return this.options.radius = this._radius = t, this.redraw() }, getRadius: function () { return this._radius }, setStyle: function (t) { var e = t && t.radius || this._radius; return mi.prototype.setStyle.call(this, t), this.setRadius(e), this }, _project: function () { this._point = this._map.latLngToLayerPoint(this._latlng), this._updateBounds() }, _updateBounds: function () { var t = this._radius, e = this._radiusY || t, i = this._clickTolerance(), i = [t + i, e + i]; this._pxBounds = new I(this._point.subtract(i), this._point.add(i)) }, _update: function () { this._map && this._updatePath() }, _updatePath: function () { this._renderer._updateCircle(this) }, _empty: function () { return this._radius && !this._renderer._bounds.intersects(this._pxBounds) }, _containsPoint: function (t) { return t.distanceTo(this._point) <= this._radius + this._clickTolerance() } }); var gi = fi.extend({ initialize: function (t, e, i) { if (_(this, e = "number" == typeof e ? l({}, i, { radius: e }) : e), this._latlng = F(t), isNaN(this.options.radius)) throw new Error("Circle radius cannot be NaN"); this._mRadius = this.options.radius }, setRadius: function (t) { return this._mRadius = t, this.redraw() }, getRadius: function () { return this._mRadius }, getBounds: function () { var t = [this._radius, this._radiusY || this._radius]; return new N(this._map.layerPointToLatLng(this._point.subtract(t)), this._map.layerPointToLatLng(this._point.add(t))) }, setStyle: mi.prototype.setStyle, _project: function () { var t, e, i, n, o, s = this._latlng.lng, r = this._latlng.lat, a = this._map, h = a.options.crs; h.distance === W.distance ? (o = Math.PI / 180, t = this._mRadius / W.R / o, e = a.project([r + t, s]), n = a.project([r - t, s]), i = e.add(n).divideBy(2), n = a.unproject(i).lat, o = Math.acos((Math.cos(t * o) - Math.sin(r * o) * Math.sin(n * o)) / (Math.cos(r * o) * Math.cos(n * o))) / o, !isNaN(o) && 0 !== o || (o = t / Math.cos(Math.PI / 180 * r)), this._point = i.subtract(a.getPixelOrigin()), this._radius = isNaN(o) ? 0 : i.x - a.project([n, s - o]).x, this._radiusY = i.y - e.y) : (h = h.unproject(h.project(this._latlng).subtract([this._mRadius, 0])), this._point = a.latLngToLayerPoint(this._latlng), this._radius = this._point.x - a.latLngToLayerPoint(h).x), this._updateBounds() } }); var vi = mi.extend({ options: { smoothFactor: 1, noClip: !1 }, initialize: function (t, e) { _(this, e), this._setLatLngs(t) }, getLatLngs: function () { return this._latlngs }, setLatLngs: function (t) { return this._setLatLngs(t), this.redraw() }, isEmpty: function () { return !this._latlngs.length }, closestLayerPoint: function (t) { for (var e = 1 / 0, i = null, n = oi, o = 0, s = this._parts.length; o < s; o++)for (var r = this._parts[o], a = 1, h = r.length; a < h; a++){ var l, c, u = n(t, l = r[a - 1], c = r[a], !0); u < e && (e = u, i = n(t, l, c)) } return i && (i.distance = Math.sqrt(e)), i }, getCenter: function () { if (!this._map) throw new Error("Must add layer to map before using getCenter()"); return ai(this._defaultShape(), this._map.options.crs) }, getBounds: function () { return this._bounds }, addLatLng: function (t, e) { return e = e || this._defaultShape(), t = F(t), e.push(t), this._bounds.extend(t), this.redraw() }, _setLatLngs: function (t) { this._bounds = new N, this._latlngs = this._convertLatLngs(t) }, _defaultShape: function () { return si(this._latlngs) ? this._latlngs : this._latlngs[0] }, _convertLatLngs: function (t) { for (var e = [], i = si(t), n = 0, o = t.length; n < o; n++)i ? (e[n] = F(t[n]), this._bounds.extend(e[n])) : e[n] = this._convertLatLngs(t[n]); return e }, _project: function () { var t = new I; this._rings = [], this._projectLatlngs(this._latlngs, this._rings, t), this._bounds.isValid() && t.isValid() && (this._rawPxBounds = t, this._updateBounds()) }, _updateBounds: function () { var t = this._clickTolerance(), t = new Z(t, t); this._rawPxBounds && (this._pxBounds = new I([this._rawPxBounds.min.subtract(t), this._rawPxBounds.max.add(t)])) }, _projectLatlngs: function (t, e, i) { var n, o, s = t[0] instanceof R, r = t.length; if (s) { for (o = [], n = 0; n < r; n++)o[n] = this._map.latLngToLayerPoint(t[n]), i.extend(o[n]); e.push(o) } else for (n = 0; n < r; n++)this._projectLatlngs(t[n], e, i) }, _clipPoints: function () { var t = this._renderer._bounds; if (this._parts = [], this._pxBounds && this._pxBounds.intersects(t)) if (this.options.noClip) this._parts = this._rings; else for (var e, i, n, o, s = this._parts, r = 0, a = 0, h = this._rings.length; r < h; r++)for (e = 0, i = (o = this._rings[r]).length; e < i - 1; e++)(n = ei(o[e], o[e + 1], t, e, !0)) && (s[a] = s[a] || [], s[a].push(n[0]), n[1] === o[e + 1] && e !== i - 2 || (s[a].push(n[1]), a++)) }, _simplifyPoints: function () { for (var t = this._parts, e = this.options.smoothFactor, i = 0, n = t.length; i < n; i++)t[i] = Qe(t[i], e) }, _update: function () { this._map && (this._clipPoints(), this._simplifyPoints(), this._updatePath()) }, _updatePath: function () { this._renderer._updatePoly(this) }, _containsPoint: function (t, e) { var i, n, o, s, r, a, h = this._clickTolerance(); if (!this._pxBounds || !this._pxBounds.contains(t)) return !1; for (i = 0, s = this._parts.length; i < s; i++)for (n = 0, o = (r = (a = this._parts[i]).length) - 1; n < r; o = n++)if ((e || 0 !== n) && ti(t, a[o], a[n]) <= h) return !0; return !1 } }); vi._flat = ri; var yi = vi.extend({ options: { fill: !0 }, isEmpty: function () { return !this._latlngs.length || !this._latlngs[0].length }, getCenter: function () { if (!this._map) throw new Error("Must add layer to map before using getCenter()"); return Xe(this._defaultShape(), this._map.options.crs) }, _convertLatLngs: function (t) { var e = vi.prototype._convertLatLngs.call(this, t), t = e.length; return 2 <= t && e[0] instanceof R && e[0].equals(e[t - 1]) && e.pop(), e }, _setLatLngs: function (t) { vi.prototype._setLatLngs.call(this, t), si(this._latlngs) && (this._latlngs = [this._latlngs]) }, _defaultShape: function () { return (si(this._latlngs[0]) ? this._latlngs : this._latlngs[0])[0] }, _clipPoints: function () { var t = this._renderer._bounds, e = this.options.weight, e = new Z(e, e), t = new I(t.min.subtract(e), t.max.add(e)); if (this._parts = [], this._pxBounds && this._pxBounds.intersects(t)) if (this.options.noClip) this._parts = this._rings; else for (var i, n = 0, o = this._rings.length; n < o; n++)(i = Ye(this._rings[n], t, !0)).length && this._parts.push(i) }, _updatePath: function () { this._renderer._updatePoly(this, !0) }, _containsPoint: function (t) { var e, i, n, o, s, r, a, h, l = !1; if (!this._pxBounds || !this._pxBounds.contains(t)) return !1; for (o = 0, a = this._parts.length; o < a; o++)for (s = 0, r = (h = (e = this._parts[o]).length) - 1; s < h; r = s++)i = e[s], n = e[r], i.y > t.y != n.y > t.y && t.x < (n.x - i.x) * (t.y - i.y) / (n.y - i.y) + i.x && (l = !l); return l || vi.prototype._containsPoint.call(this, t, !0) } }); var xi = ci.extend({ initialize: function (t, e) { _(this, e), this._layers = {}, t && this.addData(t) }, addData: function (t) { var e, i, n, o = g(t) ? t : t.features; if (o) { for (e = 0, i = o.length; e < i; e++)((n = o[e]).geometries || n.geometry || n.features || n.coordinates) && this.addData(n); return this } var s = this.options; if (s.filter && !s.filter(t)) return this; var r = wi(t, s); return r ? (r.feature = Mi(t), r.defaultOptions = r.options, this.resetStyle(r), s.onEachFeature && s.onEachFeature(t, r), this.addLayer(r)) : this }, resetStyle: function (t) { return void 0 === t ? this.eachLayer(this.resetStyle, this) : (t.options = l({}, t.defaultOptions), this._setLayerStyle(t, this.options.style), this) }, setStyle: function (e) { return this.eachLayer(function (t) { this._setLayerStyle(t, e) }, this) }, _setLayerStyle: function (t, e) { t.setStyle && ("function" == typeof e && (e = e(t.feature)), t.setStyle(e)) } }); function wi(t, e) { var i, n, o, s, r = "Feature" === t.type ? t.geometry : t, a = r ? r.coordinates : null, h = [], l = e && e.pointToLayer, c = e && e.coordsToLatLng || Li; if (!a && !r) return null; switch (r.type) { case "Point": return bi(l, t, i = c(a), e); case "MultiPoint": for (o = 0, s = a.length; o < s; o++)i = c(a[o]), h.push(bi(l, t, i, e)); return new ci(h); case "LineString": case "MultiLineString": return n = Pi(a, "LineString" === r.type ? 0 : 1, c), new vi(n, e); case "Polygon": case "MultiPolygon": return n = Pi(a, "Polygon" === r.type ? 1 : 2, c), new yi(n, e); case "GeometryCollection": for (o = 0, s = r.geometries.length; o < s; o++){ var u = wi({ geometry: r.geometries[o], type: "Feature", properties: t.properties }, e); u && h.push(u) } return new ci(h); case "FeatureCollection": for (o = 0, s = r.features.length; o < s; o++){ var d = wi(r.features[o], e); d && h.push(d) } return new ci(h); default: throw new Error("Invalid GeoJSON object.") } } function bi(t, e, i, n) { return t ? t(e, i) : new pi(i, n && n.markersInheritOptions && n) } function Li(t) { return new R(t[1], t[0], t[2]) } function Pi(t, e, i) { for (var n, o = [], s = 0, r = t.length; s < r; s++)n = e ? Pi(t[s], e - 1, i) : (i || Li)(t[s]), o.push(n); return o } function Ti(t, e) { return void 0 !== (t = F(t)).alt ? [r(t.lng, e), r(t.lat, e), r(t.alt, e)] : [r(t.lng, e), r(t.lat, e)] } function zi(t, e, i, n) { for (var o = [], s = 0, r = t.length; s < r; s++)o.push(e ? zi(t[s], si(t[s]) ? 0 : e - 1, i, n) : Ti(t[s], n)); return !e && i && 0 < o.length && o.push(o[0].slice()), o } function Si(t, e) { return t.feature ? l({}, t.feature, { geometry: e }) : Mi(e) } function Mi(t) { return "Feature" === t.type || "FeatureCollection" === t.type ? t : { type: "Feature", properties: {}, geometry: t } } U = { toGeoJSON: function (t) { return Si(this, { type: "Point", coordinates: Ti(this.getLatLng(), t) }) } }; function Ci(t, e) { return new xi(t, e) } pi.include(U), gi.include(U), fi.include(U), vi.include({ toGeoJSON: function (t) { var e = !si(this._latlngs); return Si(this, { type: (e ? "Multi" : "") + "LineString", coordinates: zi(this._latlngs, e ? 1 : 0, !1, t) }) } }), yi.include({ toGeoJSON: function (t) { var e = !si(this._latlngs), i = e && !si(this._latlngs[0]), t = zi(this._latlngs, i ? 2 : e ? 1 : 0, !0, t); return Si(this, { type: (i ? "Multi" : "") + "Polygon", coordinates: t = !e ? [t] : t }) } }), li.include({ toMultiPoint: function (e) { var i = []; return this.eachLayer(function (t) { i.push(t.toGeoJSON(e).geometry.coordinates) }), Si(this, { type: "MultiPoint", coordinates: i }) }, toGeoJSON: function (e) { var t = this.feature && this.feature.geometry && this.feature.geometry.type; if ("MultiPoint" === t) return this.toMultiPoint(e); var i = "GeometryCollection" === t, n = []; return this.eachLayer(function (t) { t.toGeoJSON && (t = t.toGeoJSON(e), i ? n.push(t.geometry) : "FeatureCollection" === (t = Mi(t)).type ? n.push.apply(n, t.features) : n.push(t)) }), i ? Si(this, { geometries: n, type: "GeometryCollection" }) : { type: "FeatureCollection", features: n } } }); var Tt = Ci, Ei = E.extend({ options: { opacity: 1, alt: "", interactive: !1, crossOrigin: !1, errorOverlayUrl: "", zIndex: 1, className: "" }, initialize: function (t, e, i) { this._url = t, this._bounds = D(e), _(this, i) }, onAdd: function () { this._image || (this._initImage(), this.options.opacity < 1 && this._updateOpacity()), this.options.interactive && (he(this._image, "leaflet-interactive"), this.addInteractiveTarget(this._image)), this.getPane().appendChild(this._image), this._reset() }, onRemove: function () { ne(this._image), this.options.interactive && this.removeInteractiveTarget(this._image) }, setOpacity: function (t) { return this.options.opacity = t, this._image && this._updateOpacity(), this }, setStyle: function (t) { return t.opacity && this.setOpacity(t.opacity), this }, bringToFront: function () { return this._map && se(this._image), this }, bringToBack: function () { return this._map && re(this._image), this }, setUrl: function (t) { return this._url = t, this._image && (this._image.src = t), this }, setBounds: function (t) { return this._bounds = D(t), this._map && this._reset(), this }, getEvents: function () { var t = { zoom: this._reset, viewreset: this._reset }; return this._zoomAnimated && (t.zoomanim = this._animateZoom), t }, setZIndex: function (t) { return this.options.zIndex = t, this._updateZIndex(), this }, getBounds: function () { return this._bounds }, getElement: function () { return this._image }, _initImage: function () { var t = "IMG" === this._url.tagName, e = this._image = t ? this._url : ie("img"); he(e, "leaflet-image-layer"), this._zoomAnimated && he(e, "leaflet-zoom-animated"), this.options.className && he(e, this.options.className), e.onselectstart = c, e.onmousemove = c, e.onload = a(this.fire, this, "load"), e.onerror = a(this._overlayOnError, this, "error"), !this.options.crossOrigin && "" !== this.options.crossOrigin || (e.crossOrigin = !0 === this.options.crossOrigin ? "" : this.options.crossOrigin), this.options.zIndex && this._updateZIndex(), t ? this._url = e.src : (e.src = this._url, e.alt = this.options.alt) }, _animateZoom: function (t) { var e = this._map.getZoomScale(t.zoom), t = this._map._latLngBoundsToNewLayerBounds(this._bounds, t.zoom, t.center).min; pe(this._image, t, e) }, _reset: function () { var t = this._image, e = new I(this._map.latLngToLayerPoint(this._bounds.getNorthWest()), this._map.latLngToLayerPoint(this._bounds.getSouthEast())), i = e.getSize(); me(t, e.min), t.style.width = i.x + "px", t.style.height = i.y + "px" }, _updateOpacity: function () { de(this._image, this.options.opacity) }, _updateZIndex: function () { this._image && void 0 !== this.options.zIndex && null !== this.options.zIndex && (this._image.style.zIndex = this.options.zIndex) }, _overlayOnError: function () { this.fire("error"); var t = this.options.errorOverlayUrl; t && this._url !== t && (this._url = t, this._image.src = t) }, getCenter: function () { return this._bounds.getCenter() } }), ki = Ei.extend({ options: { autoplay: !0, loop: !0, keepAspectRatio: !0, muted: !1, playsInline: !0 }, _initImage: function () { var t = "VIDEO" === this._url.tagName, e = this._image = t ? this._url : ie("video"); if (he(e, "leaflet-image-layer"), this._zoomAnimated && he(e, "leaflet-zoom-animated"), this.options.className && he(e, this.options.className), e.onselectstart = c, e.onmousemove = c, e.onloadeddata = a(this.fire, this, "load"), t) { for (var i = e.getElementsByTagName("source"), n = [], o = 0; o < i.length; o++)n.push(i[o].src); this._url = 0 < i.length ? n : [e.src] } else { g(this._url) || (this._url = [this._url]), !this.options.keepAspectRatio && Object.prototype.hasOwnProperty.call(e.style, "objectFit") && (e.style.objectFit = "fill"), e.autoplay = !!this.options.autoplay, e.loop = !!this.options.loop, e.muted = !!this.options.muted, e.playsInline = !!this.options.playsInline; for (var s = 0; s < this._url.length; s++){ var r = ie("source"); r.src = this._url[s], e.appendChild(r) } } } }); var Zi = Ei.extend({ _initImage: function () { var t = this._image = this._url; he(t, "leaflet-image-layer"), this._zoomAnimated && he(t, "leaflet-zoom-animated"), this.options.className && he(t, this.options.className), t.onselectstart = c, t.onmousemove = c } }); var Ai = E.extend({ options: { interactive: !1, offset: [0, 0], className: "", pane: void 0, content: "" }, initialize: function (t, e) { t && (t instanceof R || g(t)) ? (this._latlng = F(t), _(this, e)) : (_(this, t), this._source = e), this.options.content && (this._content = this.options.content) }, openOn: function (t) { return (t = arguments.length ? t : this._source._map).hasLayer(this) || t.addLayer(this), this }, close: function () { return this._map && this._map.removeLayer(this), this }, toggle: function (t) { return this._map ? this.close() : (arguments.length ? this._source = t : t = this._source, this._prepareOpen(), this.openOn(t._map)), this }, onAdd: function (t) { this._zoomAnimated = t._zoomAnimated, this._container || this._initLayout(), t._fadeAnimated && de(this._container, 0), clearTimeout(this._removeTimeout), this.getPane().appendChild(this._container), this.update(), t._fadeAnimated && de(this._container, 1), this.bringToFront(), this.options.interactive && (he(this._container, "leaflet-interactive"), this.addInteractiveTarget(this._container)) }, onRemove: function (t) { t._fadeAnimated ? (de(this._container, 0), this._removeTimeout = setTimeout(a(ne, void 0, this._container), 200)) : ne(this._container), this.options.interactive && (le(this._container, "leaflet-interactive"), this.removeInteractiveTarget(this._container)) }, getLatLng: function () { return this._latlng }, setLatLng: function (t) { return this._latlng = F(t), this._map && (this._updatePosition(), this._adjustPan()), this }, getContent: function () { return this._content }, setContent: function (t) { return this._content = t, this.update(), this }, getElement: function () { return this._container }, update: function () { this._map && (this._container.style.visibility = "hidden", this._updateContent(), this._updateLayout(), this._updatePosition(), this._container.style.visibility = "", this._adjustPan()) }, getEvents: function () { var t = { zoom: this._updatePosition, viewreset: this._updatePosition }; return this._zoomAnimated && (t.zoomanim = this._animateZoom), t }, isOpen: function () { return !!this._map && this._map.hasLayer(this) }, bringToFront: function () { return this._map && se(this._container), this }, bringToBack: function () { return this._map && re(this._container), this }, _prepareOpen: function (t) { if (!(i = this._source)._map) return !1; if (i instanceof ci) { var e, i = null, n = this._source._layers; for (e in n) if (n[e]._map) { i = n[e]; break } if (!i) return !1; this._source = i } if (!t) if (i.getCenter) t = i.getCenter(); else if (i.getLatLng) t = i.getLatLng(); else { if (!i.getBounds) throw new Error("Unable to get source layer LatLng."); t = i.getBounds().getCenter() } return this.setLatLng(t), this._map && this.update(), !0 }, _updateContent: function () { if (this._content) { var t = this._contentNode, e = "function" == typeof this._content ? this._content(this._source || this) : this._content; if ("string" == typeof e) t.innerHTML = e; else { for (; t.hasChildNodes();)t.removeChild(t.firstChild); t.appendChild(e) } this.fire("contentupdate") } }, _updatePosition: function () { var t, e, i; this._map && (t = this._map.latLngToLayerPoint(this._latlng), i = O(this.options.offset), e = this._getAnchor(), this._zoomAnimated ? me(this._container, t.add(e)) : i = i.add(t).add(e), e = this._containerBottom = -i.y, i = this._containerLeft = -Math.round(this._containerWidth / 2) + i.x, this._container.style.bottom = e + "px", this._container.style.left = i + "px") }, _getAnchor: function () { return [0, 0] } }); je.include({ _initOverlay: function (t, e, i, n) { var o = e; return o instanceof t || (o = new t(n).setContent(e)), i && o.setLatLng(i), o } }), E.include({ _initOverlay: function (t, e, i, n) { var o = i; return o instanceof t ? (_(o, n), o._source = this) : (o = e && !n ? e : new t(n, this)).setContent(i), o } }); var Oi = Ai.extend({ options: { pane: "popupPane", offset: [0, 7], maxWidth: 300, minWidth: 50, maxHeight: null, autoPan: !0, autoPanPaddingTopLeft: null, autoPanPaddingBottomRight: null, autoPanPadding: [5, 5], keepInView: !1, closeButton: !0, autoClose: !0, closeOnEscapeKey: !0, className: "" }, openOn: function (t) { return !(t = arguments.length ? t : this._source._map).hasLayer(this) && t._popup && t._popup.options.autoClose && t.removeLayer(t._popup), t._popup = this, Ai.prototype.openOn.call(this, t) }, onAdd: function (t) { Ai.prototype.onAdd.call(this, t), t.fire("popupopen", { popup: this }), this._source && (this._source.fire("popupopen", { popup: this }, !0), this._source instanceof mi || this._source.on("preclick", Ee)) }, onRemove: function (t) { Ai.prototype.onRemove.call(this, t), t.fire("popupclose", { popup: this }), this._source && (this._source.fire("popupclose", { popup: this }, !0), this._source instanceof mi || this._source.off("preclick", Ee)) }, getEvents: function () { var t = Ai.prototype.getEvents.call(this); return (void 0 !== this.options.closeOnClick ? this.options.closeOnClick : this._map.options.closePopupOnClick) && (t.preclick = this.close), this.options.keepInView && (t.moveend = this._adjustPan), t }, _initLayout: function () { var t = "leaflet-popup", e = this._container = ie("div", t + " " + (this.options.className || "") + " leaflet-zoom-animated"), i = this._wrapper = ie("div", t + "-content-wrapper", e); this._contentNode = ie("div", t + "-content", i), Ze(e), ke(this._contentNode), Le(e, "contextmenu", Ee), this._tipContainer = ie("div", t + "-tip-container", e), this._tip = ie("div", t + "-tip", this._tipContainer), this.options.closeButton && ((e = this._closeButton = ie("a", t + "-close-button", e)).setAttribute("role", "button"), e.setAttribute("aria-label", "Close popup"), e.href = "#close", e.innerHTML = '<span aria-hidden="true">&#215;</span>', Le(e, "click", function (t) { Ae(t), this.close() }, this)) }, _updateLayout: function () { var t = this._contentNode, e = t.style; e.width = "", e.whiteSpace = "nowrap"; var i = t.offsetWidth, i = Math.min(i, this.options.maxWidth); i = Math.max(i, this.options.minWidth), e.width = i + 1 + "px", e.whiteSpace = "", e.height = ""; var n = t.offsetHeight, o = this.options.maxHeight, i = "leaflet-popup-scrolled"; o && o < n ? (e.height = o + "px", he(t, i)) : le(t, i), this._containerWidth = this._container.offsetWidth }, _animateZoom: function (t) { var e = this._map._latLngToNewLayerPoint(this._latlng, t.zoom, t.center), t = this._getAnchor(); me(this._container, e.add(t)) }, _adjustPan: function () { var t, e, i, n, o, s, r, a; this.options.autoPan && (this._map._panAnim && this._map._panAnim.stop(), this._autopanning ? this._autopanning = !1 : (t = this._map, o = parseInt(ee(this._container, "marginBottom"), 10) || 0, e = this._container.offsetHeight + o, a = this._containerWidth, (s = new Z(this._containerLeft, -e - this._containerBottom))._add(fe(this._container)), i = t.layerPointToContainerPoint(s), r = O(this.options.autoPanPadding), n = O(this.options.autoPanPaddingTopLeft || r), o = O(this.options.autoPanPaddingBottomRight || r), s = t.getSize(), r = 0, i.x + a + o.x > s.x && (r = i.x + a - s.x + o.x), i.x - r - n.x < (a = 0) && (r = i.x - n.x), i.y + e + o.y > s.y && (a = i.y + e - s.y + o.y), i.y - a - n.y < 0 && (a = i.y - n.y), (r || a) && (this.options.keepInView && (this._autopanning = !0), t.fire("autopanstart").panBy([r, a])))) }, _getAnchor: function () { return O(this._source && this._source._getPopupAnchor ? this._source._getPopupAnchor() : [0, 0]) } }); je.mergeOptions({ closePopupOnClick: !0 }), je.include({ openPopup: function (t, e, i) { return this._initOverlay(Oi, t, e, i).openOn(this), this }, closePopup: function (t) { return (t = arguments.length ? t : this._popup) && t.close(), this } }), E.include({ bindPopup: function (t, e) { return this._popup = this._initOverlay(Oi, this._popup, t, e), this._popupHandlersAdded || (this.on({ click: this._openPopup, keypress: this._onKeyPress, remove: this.closePopup, move: this._movePopup }), this._popupHandlersAdded = !0), this }, unbindPopup: function () { return this._popup && (this.off({ click: this._openPopup, keypress: this._onKeyPress, remove: this.closePopup, move: this._movePopup }), this._popupHandlersAdded = !1, this._popup = null), this }, openPopup: function (t) { return this._popup && (this instanceof ci || (this._popup._source = this), this._popup._prepareOpen(t || this._latlng) && this._popup.openOn(this._map)), this }, closePopup: function () { return this._popup && this._popup.close(), this }, togglePopup: function () { return this._popup && this._popup.toggle(this), this }, isPopupOpen: function () { return !!this._popup && this._popup.isOpen() }, setPopupContent: function (t) { return this._popup && this._popup.setContent(t), this }, getPopup: function () { return this._popup }, _openPopup: function (t) { var e; this._popup && this._map && (Oe(t), e = t.layer || t.target, this._popup._source !== e || e instanceof mi ? (this._popup._source = e, this.openPopup(t.latlng)) : this._map.hasLayer(this._popup) ? this.closePopup() : this.openPopup(t.latlng)) }, _movePopup: function (t) { this._popup.setLatLng(t.latlng) }, _onKeyPress: function (t) { 13 === t.originalEvent.keyCode && this._openPopup(t) } }); var Ii = Ai.extend({ options: { pane: "tooltipPane", offset: [0, 0], direction: "auto", permanent: !1, sticky: !1, opacity: .9 }, onAdd: function (t) { Ai.prototype.onAdd.call(this, t), this.setOpacity(this.options.opacity), t.fire("tooltipopen", { tooltip: this }), this._source && (this.addEventParent(this._source), this._source.fire("tooltipopen", { tooltip: this }, !0)) }, onRemove: function (t) { Ai.prototype.onRemove.call(this, t), t.fire("tooltipclose", { tooltip: this }), this._source && (this.removeEventParent(this._source), this._source.fire("tooltipclose", { tooltip: this }, !0)) }, getEvents: function () { var t = Ai.prototype.getEvents.call(this); return this.options.permanent || (t.preclick = this.close), t }, _initLayout: function () { var t = "leaflet-tooltip " + (this.options.className || "") + " leaflet-zoom-" + (this._zoomAnimated ? "animated" : "hide"); this._contentNode = this._container = ie("div", t), this._container.setAttribute("role", "tooltip"), this._container.setAttribute("id", "leaflet-tooltip-" + h(this)) }, _updateLayout: function () { }, _adjustPan: function () { }, _setPosition: function (t) { var e, i = this._map, n = this._container, o = i.latLngToContainerPoint(i.getCenter()), s = i.layerPointToContainerPoint(t), r = this.options.direction, a = n.offsetWidth, h = n.offsetHeight, l = O(this.options.offset), i = this._getAnchor(), h = "top" === r ? (e = a / 2, h) : "bottom" === r ? (e = a / 2, 0) : (e = "center" === r ? a / 2 : "right" === r ? 0 : "left" === r ? a : s.x < o.x ? (r = "right", 0) : (r = "left", a + 2 * (l.x + i.x)), h / 2); t = t.subtract(O(e, h, !0)).add(l).add(i), le(n, "leaflet-tooltip-right"), le(n, "leaflet-tooltip-left"), le(n, "leaflet-tooltip-top"), le(n, "leaflet-tooltip-bottom"), he(n, "leaflet-tooltip-" + r), me(n, t) }, _updatePosition: function () { var t = this._map.latLngToLayerPoint(this._latlng); this._setPosition(t) }, setOpacity: function (t) { this.options.opacity = t, this._container && de(this._container, t) }, _animateZoom: function (t) { t = this._map._latLngToNewLayerPoint(this._latlng, t.zoom, t.center); this._setPosition(t) }, _getAnchor: function () { return O(this._source && this._source._getTooltipAnchor && !this.options.sticky ? this._source._getTooltipAnchor() : [0, 0]) } }); je.include({ openTooltip: function (t, e, i) { return this._initOverlay(Ii, t, e, i).openOn(this), this }, closeTooltip: function (t) { return t.close(), this } }), E.include({ bindTooltip: function (t, e) { return this._tooltip && this.isTooltipOpen() && this.unbindTooltip(), this._tooltip = this._initOverlay(Ii, this._tooltip, t, e), this._initTooltipInteractions(), this._tooltip.options.permanent && this._map && this._map.hasLayer(this) && this.openTooltip(), this }, unbindTooltip: function () { return this._tooltip && (this._initTooltipInteractions(!0), this.closeTooltip(), this._tooltip = null), this }, _initTooltipInteractions: function (t) { var e, i; !t && this._tooltipHandlersAdded || (e = t ? "off" : "on", i = { remove: this.closeTooltip, move: this._moveTooltip }, this._tooltip.options.permanent ? i.add = this._openTooltip : (i.mouseover = this._openTooltip, i.mouseout = this.closeTooltip, i.click = this._openTooltip, this._map ? this._addFocusListeners() : i.add = this._addFocusListeners), this._tooltip.options.sticky && (i.mousemove = this._moveTooltip), this[e](i), this._tooltipHandlersAdded = !t) }, openTooltip: function (t) { return this._tooltip && (this instanceof ci || (this._tooltip._source = this), this._tooltip._prepareOpen(t) && (this._tooltip.openOn(this._map), this.getElement ? this._setAriaDescribedByOnLayer(this) : this.eachLayer && this.eachLayer(this._setAriaDescribedByOnLayer, this))), this }, closeTooltip: function () { if (this._tooltip) return this._tooltip.close() }, toggleTooltip: function () { return this._tooltip && this._tooltip.toggle(this), this }, isTooltipOpen: function () { return this._tooltip.isOpen() }, setTooltipContent: function (t) { return this._tooltip && this._tooltip.setContent(t), this }, getTooltip: function () { return this._tooltip }, _addFocusListeners: function () { this.getElement ? this._addFocusListenersOnLayer(this) : this.eachLayer && this.eachLayer(this._addFocusListenersOnLayer, this) }, _addFocusListenersOnLayer: function (t) { var e = "function" == typeof t.getElement && t.getElement(); e && (Le(e, "focus", function () { this._tooltip._source = t, this.openTooltip() }, this), Le(e, "blur", this.closeTooltip, this)) }, _setAriaDescribedByOnLayer: function (t) { t = "function" == typeof t.getElement && t.getElement(); t && t.setAttribute("aria-describedby", this._tooltip._container.id) }, _openTooltip: function (t) { var e; this._tooltip && this._map && (this._map.dragging && this._map.dragging.moving() && !this._openOnceFlag ? (this._openOnceFlag = !0, (e = this)._map.once("moveend", function () { e._openOnceFlag = !1, e._openTooltip(t) })) : (this._tooltip._source = t.layer || t.target, this.openTooltip(this._tooltip.options.sticky ? t.latlng : void 0))) }, _moveTooltip: function (t) { var e = t.latlng; this._tooltip.options.sticky && t.originalEvent && (t = this._map.mouseEventToContainerPoint(t.originalEvent), t = this._map.containerPointToLayerPoint(t), e = this._map.layerPointToLatLng(t)), this._tooltip.setLatLng(e) } }); var Bi = ui.extend({ options: { iconSize: [12, 12], html: !1, bgPos: null, className: "leaflet-div-icon" }, createIcon: function (t) { var e = t && "DIV" === t.tagName ? t : document.createElement("div"), t = this.options; return t.html instanceof Element ? (oe(e), e.appendChild(t.html)) : e.innerHTML = !1 !== t.html ? t.html : "", t.bgPos && (t = O(t.bgPos), e.style.backgroundPosition = -t.x + "px " + -t.y + "px"), this._setIconStyles(e, "icon"), e }, createShadow: function () { return null } }); ui.Default = di; var Ni = E.extend({ options: { tileSize: 256, opacity: 1, updateWhenIdle: Ct.mobile, updateWhenZooming: !0, updateInterval: 200, zIndex: 1, bounds: null, minZoom: 0, maxZoom: void 0, maxNativeZoom: void 0, minNativeZoom: void 0, noWrap: !1, pane: "tilePane", className: "", keepBuffer: 2 }, initialize: function (t) { _(this, t) }, onAdd: function () { this._initContainer(), this._levels = {}, this._tiles = {}, this._resetView() }, beforeAdd: function (t) { t._addZoomLimit(this) }, onRemove: function (t) { this._removeAllTiles(), ne(this._container), t._removeZoomLimit(this), this._container = null, this._tileZoom = void 0 }, bringToFront: function () { return this._map && (se(this._container), this._setAutoZIndex(Math.max)), this }, bringToBack: function () { return this._map && (re(this._container), this._setAutoZIndex(Math.min)), this }, getContainer: function () { return this._container }, setOpacity: function (t) { return this.options.opacity = t, this._updateOpacity(), this }, setZIndex: function (t) { return this.options.zIndex = t, this._updateZIndex(), this }, isLoading: function () { return this._loading }, redraw: function () { var t; return this._map && (this._removeAllTiles(), (t = this._clampZoom(this._map.getZoom())) !== this._tileZoom && (this._tileZoom = t, this._updateLevels()), this._update()), this }, getEvents: function () { var t = { viewprereset: this._invalidateAll, viewreset: this._resetView, zoom: this._resetView, moveend: this._onMoveEnd }; return this.options.updateWhenIdle || (this._onMove || (this._onMove = n(this._onMoveEnd, this.options.updateInterval, this)), t.move = this._onMove), this._zoomAnimated && (t.zoomanim = this._animateZoom), t }, createTile: function () { return document.createElement("div") }, getTileSize: function () { var t = this.options.tileSize; return t instanceof Z ? t : new Z(t, t) }, _updateZIndex: function () { this._container && void 0 !== this.options.zIndex && null !== this.options.zIndex && (this._container.style.zIndex = this.options.zIndex) }, _setAutoZIndex: function (t) { for (var e, i = this.getPane().children, n = -t(-1 / 0, 1 / 0), o = 0, s = i.length; o < s; o++)e = i[o].style.zIndex, i[o] !== this._container && e && (n = t(n, +e)); isFinite(n) && (this.options.zIndex = n + t(-1, 1), this._updateZIndex()) }, _updateOpacity: function () { if (this._map && !Ct.ielt9) { de(this._container, this.options.opacity); var t, e = +new Date, i = !1, n = !1; for (t in this._tiles) { var o, s = this._tiles[t]; s.current && s.loaded && (o = Math.min(1, (e - s.loaded) / 200), de(s.el, o), o < 1 ? i = !0 : (s.active ? n = !0 : this._onOpaqueTile(s), s.active = !0)) } n && !this._noPrune && this._pruneTiles(), i && (S(this._fadeFrame), this._fadeFrame = z(this._updateOpacity, this)) } }, _onOpaqueTile: c, _initContainer: function () { this._container || (this._container = ie("div", "leaflet-layer " + (this.options.className || "")), this._updateZIndex(), this.options.opacity < 1 && this._updateOpacity(), this.getPane().appendChild(this._container)) }, _updateLevels: function () { var t = this._tileZoom, e = this.options.maxZoom; if (void 0 !== t) { for (var i in this._levels) i = Number(i), this._levels[i].el.children.length || i === t ? (this._levels[i].el.style.zIndex = e - Math.abs(t - i), this._onUpdateLevel(i)) : (ne(this._levels[i].el), this._removeTilesAtZoom(i), this._onRemoveLevel(i), delete this._levels[i]); var n = this._levels[t], o = this._map; return n || ((n = this._levels[t] = {}).el = ie("div", "leaflet-tile-container leaflet-zoom-animated", this._container), n.el.style.zIndex = e, n.origin = o.project(o.unproject(o.getPixelOrigin()), t).round(), n.zoom = t, this._setZoomTransform(n, o.getCenter(), o.getZoom()), c(n.el.offsetWidth), this._onCreateLevel(n)), this._level = n } }, _onUpdateLevel: c, _onRemoveLevel: c, _onCreateLevel: c, _pruneTiles: function () { if (this._map) { var t, e, i, n = this._map.getZoom(); if (n > this.options.maxZoom || n < this.options.minZoom) this._removeAllTiles(); else { for (t in this._tiles) (i = this._tiles[t]).retain = i.current; for (t in this._tiles) (i = this._tiles[t]).current && !i.active && (e = i.coords, this._retainParent(e.x, e.y, e.z, e.z - 5) || this._retainChildren(e.x, e.y, e.z, e.z + 2)); for (t in this._tiles) this._tiles[t].retain || this._removeTile(t) } } }, _removeTilesAtZoom: function (t) { for (var e in this._tiles) this._tiles[e].coords.z === t && this._removeTile(e) }, _removeAllTiles: function () { for (var t in this._tiles) this._removeTile(t) }, _invalidateAll: function () { for (var t in this._levels) ne(this._levels[t].el), this._onRemoveLevel(Number(t)), delete this._levels[t]; this._removeAllTiles(), this._tileZoom = void 0 }, _retainParent: function (t, e, i, n) { var o = Math.floor(t / 2), t = Math.floor(e / 2), e = i - 1, i = new Z(+o, +t); i.z = +e; i = this._tileCoordsToKey(i), i = this._tiles[i]; return i && i.active ? i.retain = !0 : (i && i.loaded && (i.retain = !0), n < e && this._retainParent(o, t, e, n)) }, _retainChildren: function (t, e, i, n) { for (var o = 2 * t; o < 2 * t + 2; o++)for (var s = 2 * e; s < 2 * e + 2; s++){ var r = new Z(o, s); r.z = i + 1; r = this._tileCoordsToKey(r), r = this._tiles[r]; r && r.active ? r.retain = !0 : (r && r.loaded && (r.retain = !0), i + 1 < n && this._retainChildren(o, s, i + 1, n)) } }, _resetView: function (t) { t = t && (t.pinch || t.flyTo); this._setView(this._map.getCenter(), this._map.getZoom(), t, t) }, _animateZoom: function (t) { this._setView(t.center, t.zoom, !0, t.noUpdate) }, _clampZoom: function (t) { var e = this.options; return void 0 !== e.minNativeZoom && t < e.minNativeZoom ? e.minNativeZoom : void 0 !== e.maxNativeZoom && e.maxNativeZoom < t ? e.maxNativeZoom : t }, _setView: function (t, e, i, n) { var o = Math.round(e), o = void 0 !== this.options.maxZoom && o > this.options.maxZoom || void 0 !== this.options.minZoom && o < this.options.minZoom ? void 0 : this._clampZoom(o), s = this.options.updateWhenZooming && o !== this._tileZoom; n && !s || (this._tileZoom = o, this._abortLoading && this._abortLoading(), this._updateLevels(), this._resetGrid(), void 0 !== o && this._update(t), i || this._pruneTiles(), this._noPrune = !!i), this._setZoomTransforms(t, e) }, _setZoomTransforms: function (t, e) { for (var i in this._levels) this._setZoomTransform(this._levels[i], t, e) }, _setZoomTransform: function (t, e, i) { var n = this._map.getZoomScale(i, t.zoom), i = t.origin.multiplyBy(n).subtract(this._map._getNewPixelOrigin(e, i)).round(); Ct.any3d ? pe(t.el, i, n) : me(t.el, i) }, _resetGrid: function () { var t = this._map, e = t.options.crs, i = this._tileSize = this.getTileSize(), n = this._tileZoom, o = this._map.getPixelWorldBounds(this._tileZoom); o && (this._globalTileRange = this._pxBoundsToTileRange(o)), this._wrapX = e.wrapLng && !this.options.noWrap && [Math.floor(t.project([0, e.wrapLng[0]], n).x / i.x), Math.ceil(t.project([0, e.wrapLng[1]], n).x / i.y)], this._wrapY = e.wrapLat && !this.options.noWrap && [Math.floor(t.project([e.wrapLat[0], 0], n).y / i.x), Math.ceil(t.project([e.wrapLat[1], 0], n).y / i.y)] }, _onMoveEnd: function () { this._map && !this._map._animatingZoom && this._update() }, _getTiledPixelBounds: function (t) { var e = this._map, i = e._animatingZoom ? Math.max(e._animateToZoom, e.getZoom()) : e.getZoom(), i = e.getZoomScale(i, this._tileZoom), t = e.project(t, this._tileZoom).floor(), i = e.getSize().divideBy(2 * i); return new I(t.subtract(i), t.add(i)) }, _update: function (t) { var e = this._map; if (e) { var i = this._clampZoom(e.getZoom()); if (void 0 === t && (t = e.getCenter()), void 0 !== this._tileZoom) { var n, e = this._getTiledPixelBounds(t), o = this._pxBoundsToTileRange(e), s = o.getCenter(), r = [], e = this.options.keepBuffer, a = new I(o.getBottomLeft().subtract([e, -e]), o.getTopRight().add([e, -e])); if (!(isFinite(o.min.x) && isFinite(o.min.y) && isFinite(o.max.x) && isFinite(o.max.y))) throw new Error("Attempted to load an infinite number of tiles"); for (n in this._tiles) { var h = this._tiles[n].coords; h.z === this._tileZoom && a.contains(new Z(h.x, h.y)) || (this._tiles[n].current = !1) } if (1 < Math.abs(i - this._tileZoom)) this._setView(t, i); else { for (var l = o.min.y; l <= o.max.y; l++)for (var c = o.min.x; c <= o.max.x; c++){ var u, d = new Z(c, l); d.z = this._tileZoom, this._isValidTile(d) && ((u = this._tiles[this._tileCoordsToKey(d)]) ? u.current = !0 : r.push(d)) } if (r.sort(function (t, e) { return t.distanceTo(s) - e.distanceTo(s) }), 0 !== r.length) { this._loading || (this._loading = !0, this.fire("loading")); for (var _ = document.createDocumentFragment(), c = 0; c < r.length; c++)this._addTile(r[c], _); this._level.el.appendChild(_) } } } } }, _isValidTile: function (t) { var e = this._map.options.crs; if (!e.infinite) { var i = this._globalTileRange; if (!e.wrapLng && (t.x < i.min.x || t.x > i.max.x) || !e.wrapLat && (t.y < i.min.y || t.y > i.max.y)) return !1 } if (!this.options.bounds) return !0; t = this._tileCoordsToBounds(t); return D(this.options.bounds).overlaps(t) }, _keyToBounds: function (t) { return this._tileCoordsToBounds(this._keyToTileCoords(t)) }, _tileCoordsToNwSe: function (t) { var e = this._map, i = this.getTileSize(), n = t.scaleBy(i), i = n.add(i); return [e.unproject(n, t.z), e.unproject(i, t.z)] }, _tileCoordsToBounds: function (t) { t = this._tileCoordsToNwSe(t), t = new N(t[0], t[1]); return t = !this.options.noWrap ? this._map.wrapLatLngBounds(t) : t }, _tileCoordsToKey: function (t) { return t.x + ":" + t.y + ":" + t.z }, _keyToTileCoords: function (t) { var e = t.split(":"), t = new Z(+e[0], +e[1]); return t.z = +e[2], t }, _removeTile: function (t) { var e = this._tiles[t]; e && (ne(e.el), delete this._tiles[t], this.fire("tileunload", { tile: e.el, coords: this._keyToTileCoords(t) })) }, _initTile: function (t) { he(t, "leaflet-tile"); var e = this.getTileSize(); t.style.width = e.x + "px", t.style.height = e.y + "px", t.onselectstart = c, t.onmousemove = c, Ct.ielt9 && this.options.opacity < 1 && de(t, this.options.opacity) }, _addTile: function (t, e) { var i = this._getTilePos(t), n = this._tileCoordsToKey(t), o = this.createTile(this._wrapCoords(t), a(this._tileReady, this, t)); this._initTile(o), this.createTile.length < 2 && z(a(this._tileReady, this, t, null, o)), me(o, i), this._tiles[n] = { el: o, coords: t, current: !0 }, e.appendChild(o), this.fire("tileloadstart", { tile: o, coords: t }) }, _tileReady: function (t, e, i) { e && this.fire("tileerror", { error: e, tile: i, coords: t }); var n = this._tileCoordsToKey(t); (i = this._tiles[n]) && (i.loaded = +new Date, this._map._fadeAnimated ? (de(i.el, 0), S(this._fadeFrame), this._fadeFrame = z(this._updateOpacity, this)) : (i.active = !0, this._pruneTiles()), e || (he(i.el, "leaflet-tile-loaded"), this.fire("tileload", { tile: i.el, coords: t })), this._noTilesToLoad() && (this._loading = !1, this.fire("load"), Ct.ielt9 || !this._map._fadeAnimated ? z(this._pruneTiles, this) : setTimeout(a(this._pruneTiles, this), 250))) }, _getTilePos: function (t) { return t.scaleBy(this.getTileSize()).subtract(this._level.origin) }, _wrapCoords: function (t) { var e = new Z(this._wrapX ? o(t.x, this._wrapX) : t.x, this._wrapY ? o(t.y, this._wrapY) : t.y); return e.z = t.z, e }, _pxBoundsToTileRange: function (t) { var e = this.getTileSize(); return new I(t.min.unscaleBy(e).floor(), t.max.unscaleBy(e).ceil().subtract([1, 1])) }, _noTilesToLoad: function () { for (var t in this._tiles) if (!this._tiles[t].loaded) return !1; return !0 } }); var Di = Ni.extend({ options: { minZoom: 0, maxZoom: 18, subdomains: "abc", errorTileUrl: "", zoomOffset: 0, tms: !1, zoomReverse: !1, detectRetina: !1, crossOrigin: !1, referrerPolicy: !1 }, initialize: function (t, e) { this._url = t, (e = _(this, e)).detectRetina && Ct.retina && 0 < e.maxZoom ? (e.tileSize = Math.floor(e.tileSize / 2), e.zoomReverse ? (e.zoomOffset--, e.minZoom = Math.min(e.maxZoom, e.minZoom + 1)) : (e.zoomOffset++, e.maxZoom = Math.max(e.minZoom, e.maxZoom - 1)), e.minZoom = Math.max(0, e.minZoom)) : e.zoomReverse ? e.minZoom = Math.min(e.maxZoom, e.minZoom) : e.maxZoom = Math.max(e.minZoom, e.maxZoom), "string" == typeof e.subdomains && (e.subdomains = e.subdomains.split("")), this.on("tileunload", this._onTileRemove) }, setUrl: function (t, e) { return this._url === t && void 0 === e && (e = !0), this._url = t, e || this.redraw(), this }, createTile: function (t, e) { var i = document.createElement("img"); return Le(i, "load", a(this._tileOnLoad, this, e, i)), Le(i, "error", a(this._tileOnError, this, e, i)), !this.options.crossOrigin && "" !== this.options.crossOrigin || (i.crossOrigin = !0 === this.options.crossOrigin ? "" : this.options.crossOrigin), "string" == typeof this.options.referrerPolicy && (i.referrerPolicy = this.options.referrerPolicy), i.alt = "", i.src = this.getTileUrl(t), i }, getTileUrl: function (t) { var e = { r: Ct.retina ? "@2x" : "", s: this._getSubdomain(t), x: t.x, y: t.y, z: this._getZoomForUrl() }; return this._map && !this._map.options.crs.infinite && (t = this._globalTileRange.max.y - t.y, this.options.tms && (e.y = t), e["-y"] = t), f(this._url, l(e, this.options)) }, _tileOnLoad: function (t, e) { Ct.ielt9 ? setTimeout(a(t, this, null, e), 0) : t(null, e) }, _tileOnError: function (t, e, i) { var n = this.options.errorTileUrl; n && e.getAttribute("src") !== n && (e.src = n), t(i, e) }, _onTileRemove: function (t) { t.tile.onload = null }, _getZoomForUrl: function () { var t = this._tileZoom, e = this.options.maxZoom; return (t = this.options.zoomReverse ? e - t : t) + this.options.zoomOffset }, _getSubdomain: function (t) { t = Math.abs(t.x + t.y) % this.options.subdomains.length; return this.options.subdomains[t] }, _abortLoading: function () { var t, e, i; for (t in this._tiles) this._tiles[t].coords.z !== this._tileZoom && ((i = this._tiles[t].el).onload = c, i.onerror = c, i.complete || (i.src = y, e = this._tiles[t].coords, ne(i), delete this._tiles[t], this.fire("tileabort", { tile: i, coords: e }))) }, _removeTile: function (t) { var e = this._tiles[t]; if (e) return e.el.setAttribute("src", y), Ni.prototype._removeTile.call(this, t) }, _tileReady: function (t, e, i) { if (this._map && (!i || i.getAttribute("src") !== y)) return Ni.prototype._tileReady.call(this, t, e, i) } }); function Ri(t, e) { return new Di(t, e) } var Fi = Di.extend({ defaultWmsParams: { service: "WMS", request: "GetMap", layers: "", styles: "", format: "image/jpeg", transparent: !1, version: "1.1.1" }, options: { crs: null, uppercase: !1 }, initialize: function (t, e) { this._url = t; var i, n = l({}, this.defaultWmsParams); for (i in e) i in this.options || (n[i] = e[i]); var o = (e = _(this, e)).detectRetina && Ct.retina ? 2 : 1, t = this.getTileSize(); n.width = t.x * o, n.height = t.y * o, this.wmsParams = n }, onAdd: function (t) { this._crs = this.options.crs || t.options.crs, this._wmsVersion = parseFloat(this.wmsParams.version); var e = 1.3 <= this._wmsVersion ? "crs" : "srs"; this.wmsParams[e] = this._crs.code, Di.prototype.onAdd.call(this, t) }, getTileUrl: function (t) { var e = this._tileCoordsToNwSe(t), i = this._crs, i = B(i.project(e[0]), i.project(e[1])), e = i.min, i = i.max, i = (1.3 <= this._wmsVersion && this._crs === hi ? [e.y, e.x, i.y, i.x] : [e.x, e.y, i.x, i.y]).join(","), t = Di.prototype.getTileUrl.call(this, t); return t + p(this.wmsParams, t, this.options.uppercase) + (this.options.uppercase ? "&BBOX=" : "&bbox=") + i }, setParams: function (t, e) { return l(this.wmsParams, t), e || this.redraw(), this } }); Di.WMS = Fi, Ri.wms = function (t, e) { return new Fi(t, e) }; var ji = E.extend({ options: { padding: .1 }, initialize: function (t) { _(this, t), h(this), this._layers = this._layers || {} }, onAdd: function () { this._container || (this._initContainer(), he(this._container, "leaflet-zoom-animated")), this.getPane().appendChild(this._container), this._update(), this.on("update", this._updatePaths, this) }, onRemove: function () { this.off("update", this._updatePaths, this), this._destroyContainer() }, getEvents: function () { var t = { viewreset: this._reset, zoom: this._onZoom, moveend: this._update, zoomend: this._onZoomEnd }; return this._zoomAnimated && (t.zoomanim = this._onAnimZoom), t }, _onAnimZoom: function (t) { this._updateTransform(t.center, t.zoom) }, _onZoom: function () { this._updateTransform(this._map.getCenter(), this._map.getZoom()) }, _updateTransform: function (t, e) { var i = this._map.getZoomScale(e, this._zoom), n = this._map.getSize().multiplyBy(.5 + this.options.padding), o = this._map.project(this._center, e), e = n.multiplyBy(-i).add(o).subtract(this._map._getNewPixelOrigin(t, e)); Ct.any3d ? pe(this._container, e, i) : me(this._container, e) }, _reset: function () { for (var t in this._update(), this._updateTransform(this._center, this._zoom), this._layers) this._layers[t]._reset() }, _onZoomEnd: function () { for (var t in this._layers) this._layers[t]._project() }, _updatePaths: function () { for (var t in this._layers) this._layers[t]._update() }, _update: function () { var t = this.options.padding, e = this._map.getSize(), i = this._map.containerPointToLayerPoint(e.multiplyBy(-t)).round(); this._bounds = new I(i, i.add(e.multiplyBy(1 + 2 * t)).round()), this._center = this._map.getCenter(), this._zoom = this._map.getZoom() } }), Wi = ji.extend({ options: { tolerance: 0 }, getEvents: function () { var t = ji.prototype.getEvents.call(this); return t.viewprereset = this._onViewPreReset, t }, _onViewPreReset: function () { this._postponeUpdatePaths = !0 }, onAdd: function () { ji.prototype.onAdd.call(this), this._draw() }, _initContainer: function () { var t = this._container = document.createElement("canvas"); Le(t, "mousemove", this._onMouseMove, this), Le(t, "click dblclick mousedown mouseup contextmenu", this._onClick, this), Le(t, "mouseout", this._handleMouseOut, this), t._leaflet_disable_events = !0, this._ctx = t.getContext("2d") }, _destroyContainer: function () { S(this._redrawRequest), delete this._ctx, ne(this._container), Te(this._container), delete this._container }, _updatePaths: function () { if (!this._postponeUpdatePaths) { for (var t in this._redrawBounds = null, this._layers) this._layers[t]._update(); this._redraw() } }, _update: function () { var t, e, i, n; this._map._animatingZoom && this._bounds || (ji.prototype._update.call(this), t = this._bounds, e = this._container, i = t.getSize(), n = Ct.retina ? 2 : 1, me(e, t.min), e.width = n * i.x, e.height = n * i.y, e.style.width = i.x + "px", e.style.height = i.y + "px", Ct.retina && this._ctx.scale(2, 2), this._ctx.translate(-t.min.x, -t.min.y), this.fire("update")) }, _reset: function () { ji.prototype._reset.call(this), this._postponeUpdatePaths && (this._postponeUpdatePaths = !1, this._updatePaths()) }, _initPath: function (t) { this._updateDashArray(t); t = (this._layers[h(t)] = t)._order = { layer: t, prev: this._drawLast, next: null }; this._drawLast && (this._drawLast.next = t), this._drawLast = t, this._drawFirst = this._drawFirst || this._drawLast }, _addPath: function (t) { this._requestRedraw(t) }, _removePath: function (t) { var e = t._order, i = e.next, e = e.prev; i ? i.prev = e : this._drawLast = e, e ? e.next = i : this._drawFirst = i, delete t._order, delete this._layers[h(t)], this._requestRedraw(t) }, _updatePath: function (t) { this._extendRedrawBounds(t), t._project(), t._update(), this._requestRedraw(t) }, _updateStyle: function (t) { this._updateDashArray(t), this._requestRedraw(t) }, _updateDashArray: function (t) { if ("string" == typeof t.options.dashArray) { for (var e, i = t.options.dashArray.split(/[, ]+/), n = [], o = 0; o < i.length; o++){ if (e = Number(i[o]), isNaN(e)) return; n.push(e) } t.options._dashArray = n } else t.options._dashArray = t.options.dashArray }, _requestRedraw: function (t) { this._map && (this._extendRedrawBounds(t), this._redrawRequest = this._redrawRequest || z(this._redraw, this)) }, _extendRedrawBounds: function (t) { var e; t._pxBounds && (e = (t.options.weight || 0) + 1, this._redrawBounds = this._redrawBounds || new I, this._redrawBounds.extend(t._pxBounds.min.subtract([e, e])), this._redrawBounds.extend(t._pxBounds.max.add([e, e]))) }, _redraw: function () { this._redrawRequest = null, this._redrawBounds && (this._redrawBounds.min._floor(), this._redrawBounds.max._ceil()), this._clear(), this._draw(), this._redrawBounds = null }, _clear: function () { var t, e = this._redrawBounds; e ? (t = e.getSize(), this._ctx.clearRect(e.min.x, e.min.y, t.x, t.y)) : (this._ctx.save(), this._ctx.setTransform(1, 0, 0, 1, 0, 0), this._ctx.clearRect(0, 0, this._container.width, this._container.height), this._ctx.restore()) }, _draw: function () { var t, e, i = this._redrawBounds; this._ctx.save(), i && (e = i.getSize(), this._ctx.beginPath(), this._ctx.rect(i.min.x, i.min.y, e.x, e.y), this._ctx.clip()), this._drawing = !0; for (var n = this._drawFirst; n; n = n.next)t = n.layer, (!i || t._pxBounds && t._pxBounds.intersects(i)) && t._updatePath(); this._drawing = !1, this._ctx.restore() }, _updatePoly: function (t, e) { if (this._drawing) { var i, n, o, s, r = t._parts, a = r.length, h = this._ctx; if (a) { for (h.beginPath(), i = 0; i < a; i++){ for (n = 0, o = r[i].length; n < o; n++)s = r[i][n], h[n ? "lineTo" : "moveTo"](s.x, s.y); e && h.closePath() } this._fillStroke(h, t) } } }, _updateCircle: function (t) { var e, i, n, o; this._drawing && !t._empty() && (e = t._point, i = this._ctx, n = Math.max(Math.round(t._radius), 1), 1 != (o = (Math.max(Math.round(t._radiusY), 1) || n) / n) && (i.save(), i.scale(1, o)), i.beginPath(), i.arc(e.x, e.y / o, n, 0, 2 * Math.PI, !1), 1 != o && i.restore(), this._fillStroke(i, t)) }, _fillStroke: function (t, e) { var i = e.options; i.fill && (t.globalAlpha = i.fillOpacity, t.fillStyle = i.fillColor || i.color, t.fill(i.fillRule || "evenodd")), i.stroke && 0 !== i.weight && (t.setLineDash && t.setLineDash(e.options && e.options._dashArray || []), t.globalAlpha = i.opacity, t.lineWidth = i.weight, t.strokeStyle = i.color, t.lineCap = i.lineCap, t.lineJoin = i.lineJoin, t.stroke()) }, _onClick: function (t) { for (var e, i, n = this._map.mouseEventToLayerPoint(t), o = this._drawFirst; o; o = o.next)(e = o.layer).options.interactive && e._containsPoint(n) && (("click" === t.type || "preclick" === t.type) && this._map._draggableMoved(e) || (i = e)); this._fireEvent(!!i && [i], t) }, _onMouseMove: function (t) { var e; !this._map || this._map.dragging.moving() || this._map._animatingZoom || (e = this._map.mouseEventToLayerPoint(t), this._handleMouseHover(t, e)) }, _handleMouseOut: function (t) { var e = this._hoveredLayer; e && (le(this._container, "leaflet-interactive"), this._fireEvent([e], t, "mouseout"), this._hoveredLayer = null, this._mouseHoverThrottled = !1) }, _handleMouseHover: function (t, e) { if (!this._mouseHoverThrottled) { for (var i, n, o = this._drawFirst; o; o = o.next)(i = o.layer).options.interactive && i._containsPoint(e) && (n = i); n !== this._hoveredLayer && (this._handleMouseOut(t), n && (he(this._container, "leaflet-interactive"), this._fireEvent([n], t, "mouseover"), this._hoveredLayer = n)), this._fireEvent(!!this._hoveredLayer && [this._hoveredLayer], t), this._mouseHoverThrottled = !0, setTimeout(a(function () { this._mouseHoverThrottled = !1 }, this), 32) } }, _fireEvent: function (t, e, i) { this._map._fireDOMEvent(e, i || e.type, t) }, _bringToFront: function (t) { var e, i, n = t._order; n && (e = n.next, i = n.prev, e && ((e.prev = i) ? i.next = e : e && (this._drawFirst = e), n.prev = this._drawLast, (this._drawLast.next = n).next = null, this._drawLast = n, this._requestRedraw(t))) }, _bringToBack: function (t) { var e, i, n = t._order; n && (e = n.next, (i = n.prev) && ((i.next = e) ? e.prev = i : i && (this._drawLast = i), n.prev = null, n.next = this._drawFirst, this._drawFirst.prev = n, this._drawFirst = n, this._requestRedraw(t))) } }); function Hi(t) { return Ct.canvas ? new Wi(t) : null } var Ui = function () { try { return document.namespaces.add("lvml", "urn:schemas-microsoft-com:vml"), function (t) { return document.createElement("<lvml:" + t + ' class="lvml">') } } catch (t) { } return function (t) { return document.createElement("<" + t + ' xmlns="urn:schemas-microsoft.com:vml" class="lvml">') } }(), ot = { _initContainer: function () { this._container = ie("div", "leaflet-vml-container") }, _update: function () { this._map._animatingZoom || (ji.prototype._update.call(this), this.fire("update")) }, _initPath: function (t) { var e = t._container = Ui("shape"); he(e, "leaflet-vml-shape " + (this.options.className || "")), e.coordsize = "1 1", t._path = Ui("path"), e.appendChild(t._path), this._updateStyle(t), this._layers[h(t)] = t }, _addPath: function (t) { var e = t._container; this._container.appendChild(e), t.options.interactive && t.addInteractiveTarget(e) }, _removePath: function (t) { var e = t._container; ne(e), t.removeInteractiveTarget(e), delete this._layers[h(t)] }, _updateStyle: function (t) { var e = t._stroke, i = t._fill, n = t.options, o = t._container; o.stroked = !!n.stroke, o.filled = !!n.fill, n.stroke ? (e = e || (t._stroke = Ui("stroke")), o.appendChild(e), e.weight = n.weight + "px", e.color = n.color, e.opacity = n.opacity, n.dashArray ? e.dashStyle = g(n.dashArray) ? n.dashArray.join(" ") : n.dashArray.replace(/( *, *)/g, " ") : e.dashStyle = "", e.endcap = n.lineCap.replace("butt", "flat"), e.joinstyle = n.lineJoin) : e && (o.removeChild(e), t._stroke = null), n.fill ? (i = i || (t._fill = Ui("fill")), o.appendChild(i), i.color = n.fillColor || n.color, i.opacity = n.fillOpacity) : i && (o.removeChild(i), t._fill = null) }, _updateCircle: function (t) { var e = t._point.round(), i = Math.round(t._radius), n = Math.round(t._radiusY || i); this._setPath(t, t._empty() ? "M0 0" : "AL " + e.x + "," + e.y + " " + i + "," + n + " 0,23592600") }, _setPath: function (t, e) { t._path.v = e }, _bringToFront: function (t) { se(t._container) }, _bringToBack: function (t) { re(t._container) } }, Vi = Ct.vml ? Ui : Y, qi = ji.extend({ _initContainer: function () { this._container = Vi("svg"), this._container.setAttribute("pointer-events", "none"), this._rootGroup = Vi("g"), this._container.appendChild(this._rootGroup) }, _destroyContainer: function () { ne(this._container), Te(this._container), delete this._container, delete this._rootGroup, delete this._svgSize }, _update: function () { var t, e, i; this._map._animatingZoom && this._bounds || (ji.prototype._update.call(this), e = (t = this._bounds).getSize(), i = this._container, this._svgSize && this._svgSize.equals(e) || (this._svgSize = e, i.setAttribute("width", e.x), i.setAttribute("height", e.y)), me(i, t.min), i.setAttribute("viewBox", [t.min.x, t.min.y, e.x, e.y].join(" ")), this.fire("update")) }, _initPath: function (t) { var e = t._path = Vi("path"); t.options.className && he(e, t.options.className), t.options.interactive && he(e, "leaflet-interactive"), this._updateStyle(t), this._layers[h(t)] = t }, _addPath: function (t) { this._rootGroup || this._initContainer(), this._rootGroup.appendChild(t._path), t.addInteractiveTarget(t._path) }, _removePath: function (t) { ne(t._path), t.removeInteractiveTarget(t._path), delete this._layers[h(t)] }, _updatePath: function (t) { t._project(), t._update() }, _updateStyle: function (t) { var e = t._path, t = t.options; e && (t.stroke ? (e.setAttribute("stroke", t.color), e.setAttribute("stroke-opacity", t.opacity), e.setAttribute("stroke-width", t.weight), e.setAttribute("stroke-linecap", t.lineCap), e.setAttribute("stroke-linejoin", t.lineJoin), t.dashArray ? e.setAttribute("stroke-dasharray", t.dashArray) : e.removeAttribute("stroke-dasharray"), t.dashOffset ? e.setAttribute("stroke-dashoffset", t.dashOffset) : e.removeAttribute("stroke-dashoffset")) : e.setAttribute("stroke", "none"), t.fill ? (e.setAttribute("fill", t.fillColor || t.color), e.setAttribute("fill-opacity", t.fillOpacity), e.setAttribute("fill-rule", t.fillRule || "evenodd")) : e.setAttribute("fill", "none")) }, _updatePoly: function (t, e) { this._setPath(t, X(t._parts, e)) }, _updateCircle: function (t) { var e = t._point, i = Math.max(Math.round(t._radius), 1), n = "a" + i + "," + (Math.max(Math.round(t._radiusY), 1) || i) + " 0 1,0 ", i = t._empty() ? "M0 0" : "M" + (e.x - i) + "," + e.y + n + 2 * i + ",0 " + n + 2 * -i + ",0 "; this._setPath(t, i) }, _setPath: function (t, e) { t._path.setAttribute("d", e) }, _bringToFront: function (t) { se(t._path) }, _bringToBack: function (t) { re(t._path) } }); function Gi(t) { return Ct.svg || Ct.vml ? new qi(t) : null } Ct.vml && qi.include(ot), je.include({ getRenderer: function (t) { t = (t = t.options.renderer || this._getPaneRenderer(t.options.pane) || this.options.renderer || this._renderer) || (this._renderer = this._createRenderer()); return this.hasLayer(t) || this.addLayer(t), t }, _getPaneRenderer: function (t) { if ("overlayPane" === t || void 0 === t) return !1; var e = this._paneRenderers[t]; return void 0 === e && (e = this._createRenderer({ pane: t }), this._paneRenderers[t] = e), e }, _createRenderer: function (t) { return this.options.preferCanvas && Hi(t) || Gi(t) } }); var Ki = yi.extend({ initialize: function (t, e) { yi.prototype.initialize.call(this, this._boundsToLatLngs(t), e) }, setBounds: function (t) { return this.setLatLngs(this._boundsToLatLngs(t)) }, _boundsToLatLngs: function (t) { return [(t = D(t)).getSouthWest(), t.getNorthWest(), t.getNorthEast(), t.getSouthEast()] } }); qi.create = Vi, qi.pointsToPath = X, xi.geometryToLayer = wi, xi.coordsToLatLng = Li, xi.coordsToLatLngs = Pi, xi.latLngToCoords = Ti, xi.latLngsToCoords = zi, xi.getFeature = Si, xi.asFeature = Mi, je.mergeOptions({ boxZoom: !0 }); H = wt.extend({ initialize: function (t) { this._map = t, this._container = t._container, this._pane = t._panes.overlayPane, this._resetStateTimeout = 0, t.on("unload", this._destroy, this) }, addHooks: function () { Le(this._container, "mousedown", this._onMouseDown, this) }, removeHooks: function () { Te(this._container, "mousedown", this._onMouseDown, this) }, moved: function () { return this._moved }, _destroy: function () { ne(this._pane), delete this._pane }, _resetState: function () { this._resetStateTimeout = 0, this._moved = !1 }, _clearDeferredResetState: function () { 0 !== this._resetStateTimeout && (clearTimeout(this._resetStateTimeout), this._resetStateTimeout = 0) }, _onMouseDown: function (t) { if (!t.shiftKey || 1 !== t.which && 1 !== t.button) return !1; this._clearDeferredResetState(), this._resetState(), Gt(), ge(), this._startPoint = this._map.mouseEventToContainerPoint(t), Le(document, { contextmenu: Oe, mousemove: this._onMouseMove, mouseup: this._onMouseUp, keydown: this._onKeyDown }, this) }, _onMouseMove: function (t) { this._moved || (this._moved = !0, this._box = ie("div", "leaflet-zoom-box", this._container), he(this._container, "leaflet-crosshair"), this._map.fire("boxzoomstart")), this._point = this._map.mouseEventToContainerPoint(t); var e = new I(this._point, this._startPoint), t = e.getSize(); me(this._box, e.min), this._box.style.width = t.x + "px", this._box.style.height = t.y + "px" }, _finish: function () { this._moved && (ne(this._box), le(this._container, "leaflet-crosshair")), Kt(), ve(), Te(document, { contextmenu: Oe, mousemove: this._onMouseMove, mouseup: this._onMouseUp, keydown: this._onKeyDown }, this) }, _onMouseUp: function (t) { 1 !== t.which && 1 !== t.button || (this._finish(), this._moved && (this._clearDeferredResetState(), this._resetStateTimeout = setTimeout(a(this._resetState, this), 0), t = new N(this._map.containerPointToLatLng(this._startPoint), this._map.containerPointToLatLng(this._point)), this._map.fitBounds(t).fire("boxzoomend", { boxZoomBounds: t }))) }, _onKeyDown: function (t) { 27 === t.keyCode && (this._finish(), this._clearDeferredResetState(), this._resetState()) } }); je.addInitHook("addHandler", "boxZoom", H), je.mergeOptions({ doubleClickZoom: !0 }); J = wt.extend({ addHooks: function () { this._map.on("dblclick", this._onDoubleClick, this) }, removeHooks: function () { this._map.off("dblclick", this._onDoubleClick, this) }, _onDoubleClick: function (t) { var e = this._map, i = e.getZoom(), n = e.options.zoomDelta, n = t.originalEvent.shiftKey ? i - n : i + n; "center" === e.options.doubleClickZoom ? e.setZoom(n) : e.setZoomAround(t.containerPoint, n) } }); je.addInitHook("addHandler", "doubleClickZoom", J), je.mergeOptions({ dragging: !0, inertia: !0, inertiaDeceleration: 3400, inertiaMaxSpeed: 1 / 0, easeLinearity: .2, worldCopyJump: !1, maxBoundsViscosity: 0 }); G = wt.extend({ addHooks: function () { var t; this._draggable || (t = this._map, this._draggable = new Ke(t._mapPane, t._container), this._draggable.on({ dragstart: this._onDragStart, drag: this._onDrag, dragend: this._onDragEnd }, this), this._draggable.on("predrag", this._onPreDragLimit, this), t.options.worldCopyJump && (this._draggable.on("predrag", this._onPreDragWrap, this), t.on("zoomend", this._onZoomEnd, this), t.whenReady(this._onZoomEnd, this))), he(this._map._container, "leaflet-grab leaflet-touch-drag"), this._draggable.enable(), this._positions = [], this._times = [] }, removeHooks: function () { le(this._map._container, "leaflet-grab"), le(this._map._container, "leaflet-touch-drag"), this._draggable.disable() }, moved: function () { return this._draggable && this._draggable._moved }, moving: function () { return this._draggable && this._draggable._moving }, _onDragStart: function () { var t, e = this._map; e._stop(), this._map.options.maxBounds && this._map.options.maxBoundsViscosity ? (t = D(this._map.options.maxBounds), this._offsetLimit = B(this._map.latLngToContainerPoint(t.getNorthWest()).multiplyBy(-1), this._map.latLngToContainerPoint(t.getSouthEast()).multiplyBy(-1).add(this._map.getSize())), this._viscosity = Math.min(1, Math.max(0, this._map.options.maxBoundsViscosity))) : this._offsetLimit = null, e.fire("movestart").fire("dragstart"), e.options.inertia && (this._positions = [], this._times = []) }, _onDrag: function (t) { var e, i; this._map.options.inertia && (e = this._lastTime = +new Date, i = this._lastPos = this._draggable._absPos || this._draggable._newPos, this._positions.push(i), this._times.push(e), this._prunePositions(e)), this._map.fire("move", t).fire("drag", t) }, _prunePositions: function (t) { for (; 1 < this._positions.length && 50 < t - this._times[0];)this._positions.shift(), this._times.shift() }, _onZoomEnd: function () { var t = this._map.getSize().divideBy(2), e = this._map.latLngToLayerPoint([0, 0]); this._initialWorldOffset = e.subtract(t).x, this._worldWidth = this._map.getPixelWorldBounds().getSize().x }, _viscousLimit: function (t, e) { return t - (t - e) * this._viscosity }, _onPreDragLimit: function () { var t, e; this._viscosity && this._offsetLimit && (t = this._draggable._newPos.subtract(this._draggable._startPos), e = this._offsetLimit, t.x < e.min.x && (t.x = this._viscousLimit(t.x, e.min.x)), t.y < e.min.y && (t.y = this._viscousLimit(t.y, e.min.y)), t.x > e.max.x && (t.x = this._viscousLimit(t.x, e.max.x)), t.y > e.max.y && (t.y = this._viscousLimit(t.y, e.max.y)), this._draggable._newPos = this._draggable._startPos.add(t)) }, _onPreDragWrap: function () { var t = this._worldWidth, e = Math.round(t / 2), i = this._initialWorldOffset, n = this._draggable._newPos.x, o = (n - e + i) % t + e - i, e = (n + e + i) % t - e - i, e = Math.abs(o + i) < Math.abs(e + i) ? o : e; this._draggable._absPos = this._draggable._newPos.clone(), this._draggable._newPos.x = e }, _onDragEnd: function (t) { var e, i, n, o, s = this._map, r = s.options, a = !r.inertia || t.noInertia || this._times.length < 2; s.fire("dragend", t), a ? s.fire("moveend") : (this._prunePositions(+new Date), i = this._lastPos.subtract(this._positions[0]), t = (this._lastTime - this._times[0]) / 1e3, e = r.easeLinearity, i = (a = i.multiplyBy(e / t)).distanceTo([0, 0]), t = Math.min(r.inertiaMaxSpeed, i), i = a.multiplyBy(t / i), n = t / (r.inertiaDeceleration * e), (o = i.multiplyBy(-n / 2).round()).x || o.y ? (o = s._limitOffset(o, s.options.maxBounds), z(function () { s.panBy(o, { duration: n, easeLinearity: e, noMoveStart: !0, animate: !0 }) })) : s.fire("moveend")) } }); je.addInitHook("addHandler", "dragging", G), je.mergeOptions({ keyboard: !0, keyboardPanDelta: 80 }); K = wt.extend({ keyCodes: { left: [37], right: [39], down: [40], up: [38], zoomIn: [187, 107, 61, 171], zoomOut: [189, 109, 54, 173] }, initialize: function (t) { this._map = t, this._setPanDelta(t.options.keyboardPanDelta), this._setZoomDelta(t.options.zoomDelta) }, addHooks: function () { var t = this._map._container; t.tabIndex <= 0 && (t.tabIndex = "0"), Le(t, { focus: this._onFocus, blur: this._onBlur, mousedown: this._onMouseDown }, this), this._map.on({ focus: this._addHooks, blur: this._removeHooks }, this) }, removeHooks: function () { this._removeHooks(), Te(this._map._container, { focus: this._onFocus, blur: this._onBlur, mousedown: this._onMouseDown }, this), this._map.off({ focus: this._addHooks, blur: this._removeHooks }, this) }, _onMouseDown: function () { var t, e, i; this._focused || (t = document.body, i = document.documentElement, e = t.scrollTop || i.scrollTop, i = t.scrollLeft || i.scrollLeft, this._map._container.focus(), window.scrollTo(i, e)) }, _onFocus: function () { this._focused = !0, this._map.fire("focus") }, _onBlur: function () { this._focused = !1, this._map.fire("blur") }, _setPanDelta: function (t) { for (var e = this._panKeys = {}, i = this.keyCodes, n = 0, o = i.left.length; n < o; n++)e[i.left[n]] = [-1 * t, 0]; for (n = 0, o = i.right.length; n < o; n++)e[i.right[n]] = [t, 0]; for (n = 0, o = i.down.length; n < o; n++)e[i.down[n]] = [0, t]; for (n = 0, o = i.up.length; n < o; n++)e[i.up[n]] = [0, -1 * t] }, _setZoomDelta: function (t) { for (var e = this._zoomKeys = {}, i = this.keyCodes, n = 0, o = i.zoomIn.length; n < o; n++)e[i.zoomIn[n]] = t; for (n = 0, o = i.zoomOut.length; n < o; n++)e[i.zoomOut[n]] = -t }, _addHooks: function () { Le(document, "keydown", this._onKeyDown, this) }, _removeHooks: function () { Te(document, "keydown", this._onKeyDown, this) }, _onKeyDown: function (t) { if (!(t.altKey || t.ctrlKey || t.metaKey)) { var e, i, n = t.keyCode, o = this._map; if (n in this._panKeys) o._panAnim && o._panAnim._inProgress || (i = this._panKeys[n], t.shiftKey && (i = O(i).multiplyBy(3)), o.options.maxBounds && (i = o._limitOffset(O(i), o.options.maxBounds)), o.options.worldCopyJump ? (e = o.wrapLatLng(o.unproject(o.project(o.getCenter()).add(i))), o.panTo(e)) : o.panBy(i)); else if (n in this._zoomKeys) o.setZoom(o.getZoom() + (t.shiftKey ? 3 : 1) * this._zoomKeys[n]); else { if (27 !== n || !o._popup || !o._popup.options.closeOnEscapeKey) return; o.closePopup() } Oe(t) } } }); je.addInitHook("addHandler", "keyboard", K), je.mergeOptions({ scrollWheelZoom: !0, wheelDebounceTime: 40, wheelPxPerZoomLevel: 60 }); var St = wt.extend({ addHooks: function () { Le(this._map._container, "wheel", this._onWheelScroll, this), this._delta = 0 }, removeHooks: function () { Te(this._map._container, "wheel", this._onWheelScroll, this) }, _onWheelScroll: function (t) { var e = De(t), i = this._map.options.wheelDebounceTime; this._delta += e, this._lastMousePos = this._map.mouseEventToContainerPoint(t), this._startTime || (this._startTime = +new Date); i = Math.max(i - (+new Date - this._startTime), 0); clearTimeout(this._timer), this._timer = setTimeout(a(this._performZoom, this), i), Oe(t) }, _performZoom: function () { var t = this._map, e = t.getZoom(), i = this._map.options.zoomSnap || 0; t._stop(); var n = this._delta / (4 * this._map.options.wheelPxPerZoomLevel), n = 4 * Math.log(2 / (1 + Math.exp(-Math.abs(n)))) / Math.LN2, n = i ? Math.ceil(n / i) * i : n, n = t._limitZoom(e + (0 < this._delta ? n : -n)) - e; this._delta = 0, this._startTime = null, n && ("center" === t.options.scrollWheelZoom ? t.setZoom(e + n) : t.setZoomAround(this._lastMousePos, e + n)) } }); je.addInitHook("addHandler", "scrollWheelZoom", St); je.mergeOptions({ tapHold: Ct.touchNative && Ct.safari && Ct.mobile, tapTolerance: 15 }); U = wt.extend({ addHooks: function () { Le(this._map._container, "touchstart", this._onDown, this) }, removeHooks: function () { Te(this._map._container, "touchstart", this._onDown, this) }, _onDown: function (t) { var e; clearTimeout(this._holdTimeout), 1 === t.touches.length && (e = t.touches[0], this._startPos = this._newPos = new Z(e.clientX, e.clientY), this._holdTimeout = setTimeout(a(function () { this._cancel(), this._isTapValid() && (Le(document, "touchend", Ae), Le(document, "touchend touchcancel", this._cancelClickPrevent), this._simulateEvent("contextmenu", e)) }, this), 600), Le(document, "touchend touchcancel contextmenu", this._cancel, this), Le(document, "touchmove", this._onMove, this)) }, _cancelClickPrevent: function t() { Te(document, "touchend", Ae), Te(document, "touchend touchcancel", t) }, _cancel: function () { clearTimeout(this._holdTimeout), Te(document, "touchend touchcancel contextmenu", this._cancel, this), Te(document, "touchmove", this._onMove, this) }, _onMove: function (t) { t = t.touches[0]; this._newPos = new Z(t.clientX, t.clientY) }, _isTapValid: function () { return this._newPos.distanceTo(this._startPos) <= this._map.options.tapTolerance }, _simulateEvent: function (t, e) { t = new MouseEvent(t, { bubbles: !0, cancelable: !0, view: window, screenX: e.screenX, screenY: e.screenY, clientX: e.clientX, clientY: e.clientY }); t._simulated = !0, e.target.dispatchEvent(t) } }); je.addInitHook("addHandler", "tapHold", U), je.mergeOptions({ touchZoom: Ct.touch, bounceAtZoomLimits: !0 }); ot = wt.extend({ addHooks: function () { he(this._map._container, "leaflet-touch-zoom"), Le(this._map._container, "touchstart", this._onTouchStart, this) }, removeHooks: function () { le(this._map._container, "leaflet-touch-zoom"), Te(this._map._container, "touchstart", this._onTouchStart, this) }, _onTouchStart: function (t) { var e, i, n = this._map; !t.touches || 2 !== t.touches.length || n._animatingZoom || this._zooming || (e = n.mouseEventToContainerPoint(t.touches[0]), i = n.mouseEventToContainerPoint(t.touches[1]), this._centerPoint = n.getSize()._divideBy(2), this._startLatLng = n.containerPointToLatLng(this._centerPoint), "center" !== n.options.touchZoom && (this._pinchStartLatLng = n.containerPointToLatLng(e.add(i)._divideBy(2))), this._startDist = e.distanceTo(i), this._startZoom = n.getZoom(), this._moved = !1, this._zooming = !0, n._stop(), Le(document, "touchmove", this._onTouchMove, this), Le(document, "touchend touchcancel", this._onTouchEnd, this), Ae(t)) }, _onTouchMove: function (t) { if (t.touches && 2 === t.touches.length && this._zooming) { var e = this._map, i = e.mouseEventToContainerPoint(t.touches[0]), n = e.mouseEventToContainerPoint(t.touches[1]), o = i.distanceTo(n) / this._startDist; if (this._zoom = e.getScaleZoom(o, this._startZoom), !e.options.bounceAtZoomLimits && (this._zoom < e.getMinZoom() && o < 1 || this._zoom > e.getMaxZoom() && 1 < o) && (this._zoom = e._limitZoom(this._zoom)), "center" === e.options.touchZoom) { if (this._center = this._startLatLng, 1 == o) return } else { n = i._add(n)._divideBy(2)._subtract(this._centerPoint); if (1 == o && 0 === n.x && 0 === n.y) return; this._center = e.unproject(e.project(this._pinchStartLatLng, this._zoom).subtract(n), this._zoom) } this._moved || (e._moveStart(!0, !1), this._moved = !0), S(this._animRequest); e = a(e._move, e, this._center, this._zoom, { pinch: !0, round: !1 }, void 0); this._animRequest = z(e, this, !0), Ae(t) } }, _onTouchEnd: function () { this._moved && this._zooming ? (this._zooming = !1, S(this._animRequest), Te(document, "touchmove", this._onTouchMove, this), Te(document, "touchend touchcancel", this._onTouchEnd, this), this._map.options.zoomAnimation ? this._map._animateZoom(this._center, this._map._limitZoom(this._zoom), !0, this._map.options.zoomSnap) : this._map._resetView(this._center, this._map._limitZoom(this._zoom))) : this._zooming = !1 } }); je.addInitHook("addHandler", "touchZoom", ot), je.BoxZoom = H, je.DoubleClickZoom = J, je.Drag = G, je.Keyboard = K, je.ScrollWheelZoom = St, je.TapHold = U, je.TouchZoom = ot, t.Bounds = I, t.Browser = Ct, t.CRS = j, t.Canvas = Wi, t.Circle = gi, t.CircleMarker = fi, t.Class = C, t.Control = We, t.DivIcon = Bi, t.DivOverlay = Ai, t.DomEvent = yt, t.DomUtil = vt, t.Draggable = Ke, t.Evented = k, t.FeatureGroup = ci, t.GeoJSON = xi, t.GridLayer = Ni, t.Handler = wt, t.Icon = ui, t.ImageOverlay = Ei, t.LatLng = R, t.LatLngBounds = N, t.Layer = E, t.LayerGroup = li, t.LineUtil = Pt, t.Map = je, t.Marker = pi, t.Mixin = Lt, t.Path = mi, t.Point = Z, t.PolyUtil = bt, t.Polygon = yi, t.Polyline = vi, t.Popup = Oi, t.PosAnimation = Fe, t.Projection = zt, t.Rectangle = Ki, t.Renderer = ji, t.SVG = qi, t.SVGOverlay = Zi, t.TileLayer = Di, t.Tooltip = Ii, t.Transformation = V, t.Util = M, t.VideoOverlay = ki, t.bind = a, t.bounds = B, t.canvas = Hi, t.circle = function (t, e, i) { return new gi(t, e, i) }, t.circleMarker = function (t, e) { return new fi(t, e) }, t.control = xt, t.divIcon = function (t) { return new Bi(t) }, t.extend = l, t.featureGroup = function (t, e) { return new ci(t, e) }, t.geoJSON = Ci, t.geoJson = Tt, t.gridLayer = function (t) { return new Ni(t) }, t.icon = function (t) { return new ui(t) }, t.imageOverlay = function (t, e, i) { return new Ei(t, e, i) }, t.latLng = F, t.latLngBounds = D, t.layerGroup = function (t, e) { return new li(t, e) }, t.map = function (t, e) { return new je(t, e) }, t.marker = function (t, e) { return new pi(t, e) }, t.point = O, t.polygon = function (t, e) { return new yi(t, e) }, t.polyline = function (t, e) { return new vi(t, e) }, t.popup = function (t, e) { return new Oi(t, e) }, t.rectangle = function (t, e) { return new Ki(t, e) }, t.setOptions = _, t.stamp = h, t.svg = Gi, t.svgOverlay = function (t, e, i) { return new Zi(t, e, i) }, t.tileLayer = Ri, t.tooltip = function (t, e) { return new Ii(t, e) }, t.transformation = q, t.version = "1.9.4", t.videoOverlay = function (t, e, i) { return new ki(t, e, i) }; var Yi = window.L; t.noConflict = function () { return window.L = Yi, this }, window.L = t }), L.DivIcon.SVGIcon = L.DivIcon.extend({ options: { className: "svg-icon", circleAnchor: null, circleColor: null, circleFillColor: "rgb(255,255,255)", circleFillOpacity: null, circleImageAnchor: null, circleImagePath: null, circleImageSize: null, circleOpacity: null, circleRatio: .5, circleText: "", circleWeight: null, color: "rgb(0,102,255)", fillColor: null, fillOpacity: .4, fontColor: "rgb(0, 0, 0)", fontOpacity: "1", fontSize: null, fontWeight: "normal", iconAnchor: null, iconSize: L.point(32, 48), opacity: 1, popupAnchor: null, shadowAngle: 45, shadowBlur: 1, shadowColor: "rgb(0,0,10)", shadowEnable: !1, shadowLength: .75, shadowOpacity: .5, shadowTranslate: L.point(0, 0), weight: 2 }, initialize: function (t) { (t = L.Util.setOptions(this, t)).iconSize = L.point(t.iconSize), t.circleAnchor ? t.circleAnchor = L.point(t.circleAnchor) : t.circleAnchor = L.point(Number(t.iconSize.x) / 2, Number(t.iconSize.x) / 2), t.circleColor || (t.circleColor = t.color), t.circleFillOpacity || (t.circleFillOpacity = t.opacity), t.circleOpacity || (t.circleOpacity = t.opacity), t.circleWeight || (t.circleWeight = t.weight), t.fillColor || (t.fillColor = t.color), t.fontSize || (t.fontSize = Number(t.iconSize.x / 4)), t.iconAnchor ? t.iconAnchor = L.point(t.iconAnchor) : t.iconAnchor = L.point(Number(t.iconSize.x) / 2, Number(t.iconSize.y)), t.popupAnchor ? t.popupAnchor = L.point(t.popupAnchor) : t.popupAnchor = L.point(0, -.75 * t.iconSize.y), t.circleImagePath && !t.circleImageSize ? t.circleImageSize = L.point(Number(t.iconSize.x) / 4, Number(t.iconSize.x) / 4) : t.circleImageSize = L.point(t.circleImageSize), t.circleImagePath && !t.circleImageAnchor ? t.circleImageAnchor = L.point((Number(t.iconSize.x) - Number(t.circleImageSize.x)) / 2, (Number(t.iconSize.x) - Number(t.circleImageSize.y)) / 2) : t.circleImageAnchor = L.point(t.circleImageAnchor), t.html = this._createSVG() }, _createCircle: function () { var t = Number(this.options.circleAnchor.x), e = Number(this.options.circleAnchor.y), i = this.options.iconSize.x / 2 * Number(this.options.circleRatio), n = this.options.circleFillColor, o = this.options.circleFillOpacity, s = this.options.circleColor, r = this.options.circleOpacity, a = this.options.circleWeight; return '<circle class="' + (this.options.className + "-circle") + '" cx="' + t + '" cy="' + e + '" r="' + i + '" fill="' + n + '" fill-opacity="' + o + '" stroke="' + s + '" stroke-opacity=' + r + '" stroke-width="' + a + '"/>' }, _createCircleImage: function () { return '<image x="' + this.options.circleImageAnchor.x + '" y="' + this.options.circleImageAnchor.y + '" height="' + this.options.circleImageSize.y + '" width="' + this.options.circleImageSize.x + '" href="' + this.options.circleImagePath + '"</image>' }, _createPathDescription: function () { var t = Number(this.options.iconSize.y), e = Number(this.options.iconSize.x), i = Number(this.options.weight), n = i / 2; return "M " + n + " " + e / 2 + " " + ("L " + e / 2 + " " + (t - i) + " ") + ("L " + (e - n) + " " + e / 2 + " ") + ("A " + e / 4 + " " + e / 4 + " 0 0 0 " + n + " " + e / 2 + " Z") }, _createPath: function () { var t = this._createPathDescription(), e = this.options.weight, i = this.options.color, n = this.options.opacity, o = this.options.fillColor, s = this.options.fillOpacity; return '<path class="' + (this.options.className + "-path") + '" d="' + t + '" stroke-width="' + e + '" stroke="' + i + '" stroke-opacity="' + n + '" fill="' + o + '" fill-opacity="' + s + '"/>' }, _createShadow: function () { var t = this._createPathDescription(), e = this.options.weight, i = this.options.shadowColor, n = this.options.shadowColor, o = this.options.className + "-shadow", s = this.options.iconSize.x / 2 + "px " + this.options.iconSize.y + "px", r = this.options.shadowAngle, a = this.options.shadowLength, h = this.options.shadowOpacity; return "<filter id='iconShadowBlur'><feGaussianBlur in='SourceGraphic' stdDeviation='" + this.options.shadowBlur + "'/></filter>" + ('<path filter="url(#iconShadowBlur") class="' + o + '" d="' + t + '" fill="' + n + '" stroke-width="' + e + '" stroke="' + i + '" style="opacity: ' + h + "; transform-origin: " + s + "; transform: rotate(" + r + "deg) translate(" + (this.options.shadowTranslate.x + "px, " + this.options.shadowTranslate.y + "px") + ") scale(1, " + a + ')"/>') }, _createSVG: function () { var t = this._createPath(), e = this._createCircle(), i = this.options.shadowEnable ? this._createShadow() : "", n = this.options.circleImagePath ? this._createCircleImage() : this._createText(), o = this.options.className + "-svg", s = this.options.iconSize.x, r = this.options.iconSize.y; return this.options.shadowEnable && (s += this.options.iconSize.y * this.options.shadowLength - this.options.iconSize.x / 2, s = Math.max(s, 32), r += this.options.iconSize.y * this.options.shadowLength), '<svg xmlns="http://www.w3.org/2000/svg" version="1.1" class="' + o + '" style="' + ("width:" + s + "px; height:" + r) + '">' + i + t + e + n + "</svg>" }, _createText: function () { var t = this.options.fontSize + "px", e = this.options.fontWeight, i = Number(this.options.fontSize), n = this.options.circleAnchor.x, o = this.options.circleAnchor.y + .35 * i, i = this.options.circleText; return '<text text-anchor="middle" x="' + n + '" y="' + o + '" style="font-size: ' + t + "; font-weight: " + e + '" fill="' + this.options.fontColor.replace("rgb(", "rgba(").replace(")", "," + this.options.fontOpacity + ")") + '">' + i + "</text>" } }), L.divIcon.svgIcon = function (t) { return new L.DivIcon.SVGIcon(t) }, L.Marker.SVGMarker = L.Marker.extend({ options: { iconFactory: L.divIcon.svgIcon, iconOptions: {} }, initialize: function (t, e) { (e = L.Util.setOptions(this, e)).icon = e.iconFactory(e.iconOptions), this._latlng = t }, onAdd: function (t) { L.Marker.prototype.onAdd.call(this, t) }, setStyle: function (t) { var e, i, n, o; this._icon && (this._icon.children[0], e = this._icon.children[0].children[0], i = this._icon.children[0].children[1], t.color && !t.iconOptions && (n = t.color.replace("rgb", "rgba").replace(")", "," + this.options.icon.options.opacity + ")"), o = t.color.replace("rgb", "rgba").replace(")", "," + this.options.icon.options.fillOpacity + ")"), e.setAttribute("stroke", n), e.setAttribute("fill", o), i.setAttribute("stroke", n), this.options.icon.fillColor = o, this.options.icon.color = n, this.options.icon.circleColor = n), t.opacity && this.setOpacity(t.opacity), t.iconOptions && (t.color && (t.iconOptions.color = t.color), t = L.Util.setOptions(this.options.icon, t.iconOptions), this.setIcon(L.divIcon.svgIcon(t)))) } }), L.marker.svgMarker = function (t, e) { return new L.Marker.SVGMarker(t, e) }, function () { L.Control.FullScreen = L.Control.extend({ options: { position: "topleft", title: "Full Screen", titleCancel: "Exit Full Screen", forceSeparateButton: !1, forcePseudoFullscreen: !1, fullscreenElement: !1 }, onAdd: function (t) { var e = "leaflet-control-zoom-fullscreen", i = "", t = t.zoomControl && !this.options.forceSeparateButton ? t.zoomControl._container : L.DomUtil.create("div", "leaflet-bar"); return this.options.content ? i = this.options.content : e += " fullscreen-icon", this._createButton(this.options.title, e, i, t, this.toggleFullScreen, this), (this._map.fullscreenControl = this)._map.on("enterFullscreen exitFullscreen", this._toggleTitle, this), t }, onRemove: function (t) { L.DomEvent.off(this.link, "click", L.DomEvent.stopPropagation).off(this.link, "click", L.DomEvent.preventDefault).off(this.link, "click", this.toggleFullScreen, this), L.DomEvent.off(this._container, r.fullScreenEventName, L.DomEvent.stopPropagation).off(this._container, r.fullScreenEventName, L.DomEvent.preventDefault).off(this._container, r.fullScreenEventName, this._handleFullscreenChange, this), L.DomEvent.off(document, r.fullScreenEventName, L.DomEvent.stopPropagation).off(document, r.fullScreenEventName, L.DomEvent.preventDefault).off(document, r.fullScreenEventName, this._handleFullscreenChange, this) }, _createButton: function (t, e, i, n, o, s) { return this.link = L.DomUtil.create("a", e, n), this.link.href = "#", this.link.title = t, this.link.innerHTML = i, this.link.setAttribute("role", "button"), this.link.setAttribute("aria-label", t), L.DomEvent.on(this.link, "click", L.DomEvent.stopPropagation).on(this.link, "click", L.DomEvent.preventDefault).on(this.link, "click", o, s), L.DomEvent.on(n, r.fullScreenEventName, L.DomEvent.stopPropagation).on(n, r.fullScreenEventName, L.DomEvent.preventDefault).on(n, r.fullScreenEventName, this._handleFullscreenChange, s), L.DomEvent.on(document, r.fullScreenEventName, L.DomEvent.stopPropagation).on(document, r.fullScreenEventName, L.DomEvent.preventDefault).on(document, r.fullScreenEventName, this._handleFullscreenChange, s), this.link }, toggleFullScreen: function () { var t = this._map; t._exitFired = !1, t._isFullscreen ? (r.supportsFullScreen && !this.options.forcePseudoFullscreen ? r.cancelFullScreen() : L.DomUtil.removeClass(this.options.fullscreenElement || t._container, "leaflet-pseudo-fullscreen"), t.fire("exitFullscreen"), t._exitFired = !0, t._isFullscreen = !1) : (r.supportsFullScreen && !this.options.forcePseudoFullscreen ? r.requestFullScreen(this.options.fullscreenElement || t._container) : L.DomUtil.addClass(this.options.fullscreenElement || t._container, "leaflet-pseudo-fullscreen"), t.fire("enterFullscreen"), t._isFullscreen = !0) }, _toggleTitle: function () { this.link.title = this._map._isFullscreen ? this.options.title : this.options.titleCancel }, _handleFullscreenChange: function () { var t = this._map; t.invalidateSize(), r.isFullScreen() || t._exitFired || (t.fire("exitFullscreen"), t._exitFired = !0, t._isFullscreen = !1) } }), L.Map.include({ toggleFullscreen: function () { this.fullscreenControl.toggleFullScreen() } }), L.Map.addInitHook(function () { this.options.fullscreenControl && this.addControl(L.control.fullscreen(this.options.fullscreenControlOptions)) }); var r = { supportsFullScreen: !(L.control.fullscreen = function (t) { return new L.Control.FullScreen(t) }), isFullScreen: function () { return !1 }, requestFullScreen: function () { }, cancelFullScreen: function () { }, fullScreenEventName: "", prefix: "" }, t = "webkit moz o ms khtml".split(" "); if (void 0 !== document.exitFullscreen) r.supportsFullScreen = !0; else { for (var e = 0, i = t.length; e < i; e++)if (r.prefix = t[e], void 0 !== document[r.prefix + "CancelFullScreen"]) { r.supportsFullScreen = !0; break } void 0 !== document.msExitFullscreen && (r.prefix = "ms", r.supportsFullScreen = !0) } r.supportsFullScreen && ("ms" === r.prefix ? r.fullScreenEventName = "MSFullscreenChange" : r.fullScreenEventName = r.prefix + "fullscreenchange", r.isFullScreen = function () { switch (this.prefix) { case "": return document.fullscreen; case "webkit": return document.webkitIsFullScreen; case "ms": return document.msFullscreenElement; default: return document[this.prefix + "FullScreen"] } }, r.requestFullScreen = function (t) { switch (this.prefix) { case "": return t.requestFullscreen(); case "ms": return t.msRequestFullscreen(); default: return t[this.prefix + "RequestFullScreen"]() } }, r.cancelFullScreen = function () { switch (this.prefix) { case "": return document.exitFullscreen(); case "ms": return document.msExitFullscreen(); default: return document[this.prefix + "CancelFullScreen"]() } }), "undefined" != typeof jQuery && (jQuery.fn.requestFullScreen = function () { return this.each(function () { var t = jQuery(this); r.supportsFullScreen && r.requestFullScreen(t) }) }), window.fullScreenApi = r }();